import{default as e}from"@sindresorhus/is";import{default as t}from"body-parser";import{default as r}from"express";import{default as n}from"got";import{nanoid as o}from"nanoid";import{bootstrap as s}from"renovate/dist/proxy.js";import{default as i}from"renovate/dist/util/cache/package/index.js";import{default as a}from"renovate/dist/util/cache/package/redis.js";import{default as c}from"renovate/dist/workers/global/config/parse/index.js";import{createRequire as u}from"node:module";import{default as l}from"delay";import{default as p}from"fs-extra";import{logger as d}from"renovate/dist/logger/index.js";import{default as g}from"upath";import{DefaultAzureCredential as f}from"@azure/identity";import{SecretClient as m}from"@azure/keyvault-secrets";import{default as h}from"proper-url-join";import{default as b}from"jsonwebtoken";import{default as y}from"tunnel";import{mergeChildConfig as v}from"renovate/dist/config/index.js";import{getConfig as E}from"renovate/dist/config/defaults.js";import{getOptions as R}from"renovate/dist/config/options/index.js";import{GithubHttp as T}from"renovate/dist/util/http/github.js";import{GitlabHttp as _}from"renovate/dist/util/http/gitlab.js";import{default as O}from"renovate/dist/modules/versioning/index.js";import{default as N}from"semver";import{CronJob as S}from"cron";import{initPlatform as k}from"renovate/dist/modules/platform/bitbucket-server/index.js";import{rawExec as w}from"renovate/dist/util/exec/common.js";import{initPlatform as A}from"renovate/dist/modules/platform/gitlab/index.js";import{default as I}from"buffer-equal-constant-time";import{default as P}from"minimatch";import{default as V}from"parse-link-header";import"renovate/dist/util/host-rules.js";import{configure as D}from"safe-stable-stringify";import{default as L}from"bunyan";import{default as x}from"split2";import{PutObjectCommand as U,S3Client as M}from"@aws-sdk/client-s3";import{Upload as C}from"@aws-sdk/lib-storage";import{parseS3Url as j}from"renovate/dist/util/s3.js";var q={d:(e,t)=>{for(var r in t)q.o(t,r)&&!q.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},F={};q.r(F),q.d(F,{massagePackageRules:()=>Ge});var K={};q.r(K),q.d(K,{fetchIssues:()=>He,massagePackageRules:()=>Ye});var B={};q.r(B),q.d(B,{massagePackageRules:()=>Je});var $={};q.r($),q.d($,{fetchIssues:()=>Xe,massagePackageRules:()=>Qe});var W={};q.r(W),q.d(W,{fetchIssues:()=>et,massagePackageRules:()=>tt});const G=u(import.meta.url)("crypto");let H,Y,J;function z(){if(Y)return{name:"Authorization",value:J}}function X(e){return z()||function(e){if(!process.env.WS_API_SECRET||!e)return;const t=e.split("?")[1];return{name:"ws-auth",value:G.createHmac("sha1",H).update(t).digest("hex")}}(e)}function Q(e,t,r){if(!Y)return r();const n=(e.headers.authorization||"").replace("Bearer ","");return n.length?n!==Y?t.status(403).json({error:"Secret provided is incorrect"}):r():t.status(401).json({error:"Secret is required but is missing"})}function Z(e,t,r){if(!H)return r();const n=(e.headers.authorization||"").replace("Bearer ","");return n.length?n!==H?t.status(403).json({error:"Secret provided is incorrect"}):r():t.status(401).json({error:"Secret is required but is missing"})}function ee(e){const t=g.dirname(e);return p.ensureDirSync(t,{recursive:!0}),{name:"logfile",level:"debug",path:e}}H=process.env.WS_API_SECRET,Y=process.env.REMEDIATE_SERVER_SECRET,J=`Bearer ${Y}`;const te=new class{constructor(e){this.logger=e,this.baseLogger=void 0}trace(e,t){this.log("trace",e,t)}debug(e,t){this.log("debug",e,t)}info(e,t){this.log("info",e,t)}warn(e,t){this.log("warn",e,t)}error(e,t){this.log("error",e,t)}fatal(e,t){this.log("fatal",e,t)}log(t,r,n){e.string(r)?this.logger[t](r):this.logger[t](r,n)}addStream(t){if(!e.nullOrUndefined(this.baseLogger))return void this.logger.debug("addStream: stream already attached; discarding request");if(!e.function_(this.logger.addStream))return;if(!e.function_(this.logger.childLogger))return;this.baseLogger=this.logger;const r=this.logger.childLogger();r.addStream(t),this.logger=r}removeStream(){e.nullOrUndefined(this.baseLogger)?this.logger.trace("removeStream: no attached stream to discard"):this.logger=this.baseLogger}setContext(e){this.logger.logContext=e}getContext(){return this.logger.logContext}setMeta(t){e.function_(this.logger.setMeta)&&this.logger.setMeta(t)}addMeta(t){e.function_(this.logger.addMeta)&&this.logger.addMeta(t)}removeMeta(t){e.function_(this.logger.removeMeta)&&this.logger.removeMeta(t)}}(d),re=te,ne={checkRunSettings:{vulnerableCheckRunConclusionLevel:"failure",licenseCheckRunConclusionLevel:"failure",iacCheckRunConclusionLevel:"failure",displayMode:"diff",showWsInfo:!1,useMendCheckNames:!0,strictMode:"none",strictModeInfo:!1},checkRunSettingsSAST:{checkRunConclusionLevel:"failure",severityThreshold:"high"},generalSettings:{shouldScanRepo:!0},scanSettings:{configMode:"AUTO",configExternalURL:"",projectToken:"",baseBranches:[],releaseBranches:[],enableLicenseViolations:!1,enableIaC:!1,enableSAST:!1,enableSASTRemediation:!1,cloneSubmodules:!1,enableReachability:!1,scanDependabotPR:!1,repoNameSync:!1,exploitability:!1,uaConfig:{}},scanSettingsSAST:{configExternalURL:"",snippetSize:10,enableScan:!1,enableRemediation:!1,scanPullRequests:!1,incrementalScan:!0,baseBranches:[]},imageSettings:{imageTracing:{enableImageTracingPR:!1,addRepositoryCoordinate:!1,addDockerfilePath:!1,addMendIdentifier:!1}},issueSettings:{minSeverityLevel:"LOW",openConfidentialIssues:!0,displayLicenseViolations:!0,issueType:"DEPENDENCY",assignees:[],customLabels:[],customFields:{}},issueSettingsSAST:{minSeverityLevel:"high",issueType:"repo"},leastVulnerablePackageSettings:{enabled:!1},fileExistsInRepository:!0,remediateSettings:{renovateStrategy:"full",workflowRules:{enabled:!0},dependencyDashboard:!0},errors:[],cachedDate:1724932135491};function oe(e){try{const t=process.env[e];return t?JSON.parse(t):void re.debug({key:e},"No env variable found for dummy data")}catch(t){return void re.error({key:e,err:t},"Error reading dummy data from env")}}let se=null,ie=null,ae=null,ce=0,ue=null,le=[];function pe(e){return e<new Date-36e5}let de=[];process.env.REMEDIATE_LOCAL_DEV&&(de=[oe("DUMMY_NEXT_JOB")||JSON.parse(JSON.stringify({reason:"master-issue-check",repository:"nabeelsaabnaTests/demo-for-justin-mc",uniqueKey:"nabeelsaabnaTests/demo-for-justin-mc",priority:17,logContext:"ebaebd3736294c17b76f805c32874855",params:{collectionId:"33326816",repoId:"841425164"},installationId:"32557243"}))]);const ge={remediate:8,"rebase-request":15,"master-issue-check":17,"onboarding-update":20,"pr-update":30,"closed-pr-rename":35,"manual-pr-merge":40,"repositories-added":50,installed:60,"master-commit":70,automerge:80,"manual-pr-close":90,scheduled:100};function fe(e,t,r,n,o={}){const s=ge[t]||100;for(let i=0;i<r.length;i+=1){se=new Date;const a=r[i];re.debug({uniqueKey:a.uniqueKey,repository:a.repository,reason:t,priority:s},"Job queue: enqueing job");const c=de.find(e=>e.uniqueKey===a.uniqueKey);if(c)re.debug({repository:c.repository,uniqueKey:c.uniqueKey},"Job queue: Existing job found for repository"),c.priority>s?(re.debug({repository:c.repository,uniqueKey:c.uniqueKey,existingPriority:c.priority,priority:s},"Job queue: Increasing priority of existing job"),c.reason=t,c.priority=s,c.logContext=e):re.debug({repository:a,existingPriority:c.priority,priority:s},"Job queue: Existing job does not need priority bump");else{const r={reason:t,repository:a.repository,uniqueKey:a.uniqueKey,priority:s,logContext:e,params:o};n&&(r.installationId=n[i]),de.push(r)}ve()}}const me={};function he(e,t,r,n=[],o={}){if("remediate"===t){re.trace("Remediate event received");for(let t=0;t<r.length;t+=1){const s=r[t],i=n[t];me[s.uniqueKey]&&(re.debug({repository:s.uniqueKey},"Debouncing"),clearTimeout(me[s.uniqueKey])),me[s.uniqueKey]=setTimeout(()=>{re.debug({repository:s.uniqueKey},"Enqueuing remediate job"),delete me[s.uniqueKey],fe(e,"remediate",[s],[i],o)},1e4)}}else fe(e,t,r,n,o)}function be(e){re.debug({repos:e},"Job queue: Dequeuing repositories"),de=de.filter(t=>!e.includes(t.uniqueKey))}async function ye(){if(global.remediateServerUrl)try{re.trace(`Fetching next job from ${global.remediateServerUrl}`);const e={timeout:{request:1e4}},t=z();return t&&(e.headers={[t.name]:t.value}),(await n(`${global.remediateServerUrl}/jobs/next`,e).json()).job}catch(e){return re.info({err:e},"Error getting next job from remediate-server"),re.debug("Sleeping 10s"),await l(1e4),null}!function(){for(;le.length&&pe(le[0].started);)le.shift()}();const e=le.map(e=>e.repository),t=de.findIndex(t=>!e.includes(t.uniqueKey));if(-1===t)return null;const r=de[t];return de.splice(t,1),re.debug({job:r},"Job queue: returning next job"),ae=r,ie=new Date,ce+=1,le.push({uniqueKey:r.uniqueKey,repository:r.repository,started:ie}),r}function ve(){de.sort((e,t)=>e.priority-t.priority)}async function Ee(e){if(global.remediateServerUrl)try{const t={json:{job:e}},r=z();r&&(t.headers={[r.name]:r.value}),await n.put(`${global.remediateServerUrl}/jobs/finish`,t)}catch(e){re.warn({err:e},"Error sending finish job to remediate-server"),re.debug("Sleeping 10s"),await l(1e4)}else re.debug({job:e},"Job queue: job finished"),ue={...e,finished:new Date},le=le.filter(t=>t.uniqueKey!==e.uniqueKey)}const Re="-----BEGIN PGP PRIVATE KEY BLOCK-----\n\n";function Te(e){let t=e;return t.startsWith(Re)||(re.debug("Massaging PGP key header and footer"),t=`${Re}${t}\n-----END PGP PRIVATE KEY BLOCK-----`),t}async function _e(){let t;try{t=await async function(){const t=Oe(),r=process.env.GH_APP_KEYVAULT_SECRET_GPG||"HostRules";let n;if(re.debug(`Fetching GPG key from Vault ${r}`),e.string(process.env.WS_HOST_RULES_PRIVATE_KEY))re.info("Using GPG key from env"),n=process.env.WS_HOST_RULES_PRIVATE_KEY;else{re.info("Fetching PGP key from Vault");const{value:e}=await t.getSecret(r);n=Te(e),re.info("Retrieved GPG key from Vault")}return n}()}catch(e){re.error({err:e},"Error retrieving host rule secret"),process.exit()}return t}function Oe(){const e=new f;return new m(process.env.AZURE_KEYVAULT_LOCATION,e)}const Ne=u(import.meta.url)("url"),Se=u(import.meta.url)("fs");function ke(e){return e.charCodeAt(0)-4}function we(e,t){const r=Buffer.from(""),n=G.createHash("SHA1").update(e).digest().slice(0,16),o=G.createDecipheriv("aes-128-ecb",n,r);return o.update(t,"base64","utf8")+o.final("utf8")}async function Ae(e,t,r="github"){re.debug(`fetchActivatioDetails(platform=${r})`);const o={};t&&(re.info("Found proxy configuration in prop.json: "+t),process.env.HTTP_PROXY?re.info("Found HTTP_PROXY configuration in env - using it instead"):(re.debug("Setting HTTP_PROXY: "+t),process.env.HTTP_PROXY=t),process.env.HTTPS_PROXY?re.info("Found HTTPS_PROXY configuration in env - using it instead"):(re.debug("Setting HTTPS_PROXY: "+t),process.env.HTTPS_PROXY=t));const s=process.env.HTTPS_PROXY||process.env.HTTP_PROXY;if(s){re.debug("Querying WSS server using proxy: "+s);const e=Ne.parse(s),t={};let r;t.host=e.hostname,t.port=e.port,t.proxyAuth=e.auth,re.debug({proxy:t},"Proxy details"),"http:"===e.protocol?(re.debug("Tunneling https over http"),r=y.httpsOverHttp({proxy:t})):(re.debug("Tunneling https over https"),r=y.httpsOverHttps({proxy:t})),o.agent={https:r}}const i=e.wsEnvIdentifier.replace("/api","/internal/v1.0");let a;re.debug("Trying URL: "+i),o.json={requestType:"getAgentConfiguration",userKey:e.userKey,orgToken:e.orgToken,agentType:{github:"bolt-4-op-github-scanner",gitlab:"bolt-4-op-gitlab-scanner","bitbucket-server":"bolt-4-op-bitbucket-scanner"}[r],agentVersion:"19.2.2",configVer:e.confVer};try{a=await n.post(i,o).json()}catch(e){re.debug({err:e},"Error retrieving from Mend server")}if(a||(re.error("Cannot retrieve details from Mend server"),process.exit()),a.message&&a.message.startsWith("No configuration")){const n={github:"bitbucket-server","bitbucket-server":"gitlab"}[r];if(n)return re.debug("Trying "+n),Ae(e,t,n);re.error("No configuration found - exiting"),process.exit()}return{...a,platform:r}}async function Ie(){re.info("Initializing Mend Remediate Enterprise config");const t=function(){if(process.env.WS_CONFIG_OVERRIDE&&process.env.RENOVATE_PLATFORM&&process.env.RENOVATE_ENDPOINT&&(process.env.RENOVATE_TOKEN||process.env.RENOVATE_USERNAME&&process.env.RENOVATE_PASSWORD))return{platform:process.env.RENOVATE_PLATFORM,endpoint:process.env.RENOVATE_ENDPOINT,token:process.env.RENOVATE_TOKEN,username:process.env.RENOVATE_USERNAME,password:process.env.RENOVATE_PASSWORD}}();if(t)return re.info("Using manual credentials and skipping activation key"),t;const r={};try{const{decoded:t,propJson:o}=function(){let e=process.env.WS_ACTIVATION_KEY||process.env.W4D_BOLT_OP_ACTIVATION_KEY;e&&re.info("Read activation key from env");const t=process.env.WS_PROP_JSON_FILE_PATH||process.env.WS_PROP_JSON||"/etc/usr/local/whitesource/conf/prop.json";let r,n;try{re.debug("Attempting to read prop.json file from "+t),r=Se.readFileSync(t,"utf8")}catch(n){re.debug("Could not read "+t);try{re.debug("Attempting to read prop.json file from /etc/whitesource/prop.json"),r=Se.readFileSync("/etc/whitesource/prop.json","utf8"),re.warn("/etc/whitesource/prop.json is now deprecated. Please use /etc/usr/local/whitesource/conf/prop.json instead")}catch(t){e||(re.error("Could not locate prop.json config file - exiting"),process.exit()),re.debug("Could not read /etc/whitesource/prop.json either. Skipping prop.json and reading from env instead.")}}if(r){try{n=JSON.parse(r),re.debug("Parsed prop.json file")}catch(e){re.error({err:e},"Cannot parse prop.json file"),process.exit()}if(n.properties||(re.error('Cannot find "properties" field of prop.json'),process.exit()),!e){let t;try{t=n.properties.find(e=>"bolt.op.activation.key"===e.propertyName),t||(re.error('Cannot find "bolt.op.activation.key" object in properties'),process.exit()),re.debug("Found activation key object")}catch(e){re.error('Error finding "bolt.op.activation.key" object in properties'),process.exit()}t.propertyValue||(re.error("Cannot find propertyValue of activation key"),process.exit()),re.info("Read activation key from prop.json"),e=t.propertyValue}}const o=e.replace(/\\\\/g,"\\");let s;try{re.debug("Massaging activation key");const e=o.split("").map(ke);let t="";e.forEach(e=>{var r;t+=(r=e,String.fromCharCode(r))}),t=t.split("").reverse().join(""),s=Buffer.from(t,"base64").toString("ascii");const r=b.verify(s,"whiteSourceSecret");return re.debug("Decoded activation key"),{decoded:r,propJson:n}}catch(e){re.debug({activationKey:o,text:s,err:e},"Activation decode error"),re.error("Cannot decode activation key"),process.exit()}return{}}(),s=o?function(e){const t=e.find(e=>"proxy.host"===e.propertyName),r=t&&t.propertyValue;if(!r||!r.length)return re.info("No proxy defined."),null;const n=e.find(e=>"proxy.for.all.param"===e.propertyName);n&&"true"===n.propertyValue.toString()?(re.debug("proxy.for.all is true"),process.env.MEND_PROXY_ALL=!0):re.debug("proxy.for.all is false");let o=r;o.match(/https?:\/\//)||(re.debug("No http prefix found. Adding http:// prefix to proxy"),o="http://"+o);const s=e.find(e=>"proxy.port"===e.propertyName),i=s&&s.propertyValue;i&&i.length?o+=":"+i:re.debug("Warning: found proxy host but not proxy port");const a=e.find(e=>"proxy.user"===e.propertyName),c=a&&a.propertyValue;if(!c||!c.length)return re.debug("No proxy user defined"),o;o=o.replace("://",`://${c}@`);const u=e.find(e=>"proxy.password"===e.propertyName),l=u&&u.propertyValue;return l&&l.length?(o=o.replace(c,`${c}:${l}`),o):(re.debug("Warning: No proxy password defined"),o)}(o.properties):null,i=await Ae(t,s),a=i.platform;if(r.platform=i.platform,"github"===a){r.endpoint=i.configuration.scmApiUrl.replace(/\/?$/,"/"),process.env.GITHUB_APP_ID=i.configuration.applicationId;const e=i.configuration.privateKey.replace("encrypt:",""),n=we(t.secretKey,e);process.env.GITHUB_APP_KEY=n}else if("gitlab"===a){r.endpoint=i.configuration.scmUrl.replace(/\/?$/,"/");const e=i.configuration.accessToken.replace("encrypt:",""),n=we(t.secretKey,e);r.token=n}else{const e=i.configuration.scmUrl.replace(/\/?$/,"/");r.endpoint=e,e.startsWith("http://")?process.env.RENOVATE_GIT_FS="http":process.env.RENOVATE_GIT_FS="https";const o=i.configuration.accessToken.replace("encrypt:",""),s=we(t.secretKey,o);r.username=i.configuration.user,r.password=s;const a=await async function(e){try{const t=h(e,"/rest/api/1.0/application-properties");return(await n.get(t).json()).version}catch(e){return re.error({err:e},"Could not retrieve Bitbucket version"),null}}(e),c=function(e){return!!e&&parseInt(e.split(".")[0],10)>=9}(a);re.info({version:a,useBasicAuth:c},"Bitbucket version and authentication method determined"),global.bitbucketUseBasicAuth=c}const c="gitlab"===process.env.RENOVATE_PLATFORM?"http://wss-gls-app:5678":"http://wss-ghe-app:5678",u=o&&o.properties.find(e=>"controller.url"===e.propertyName);if(process.env.WS_CONTROLLER_DESTINATION_URL||(process.env.CONTROLLER_DESTINATION_URL?process.env.WS_CONTROLLER_DESTINATION_URL=process.env.CONTROLLER_DESTINATION_URL:process.env.WS_CONTROLLER_DESTINATION_URL=u&&u.propertyValue?u.propertyValue:c),re.info({controllerUrl:process.env.WS_CONTROLLER_DESTINATION_URL},"Successfully retrieved controllerUrl from Mend Enterprise config"),process.env.HTTP_PROXY||process.env.HTTPS_PROXY){e.string(process.env.NO_PROXY)?(re.debug("Using NO_PROXY found in env"),process.env.MEND_PROXY_ALL&&re.warn("Be aware that proxy.for.all setting will be ignored as a custom NO_PROXY is already defined")):process.env.MEND_PROXY_ALL?(re.debug("Proxying all"),process.env.NO_PROXY=""):(re.debug("Setting code platform in NO_PROXY"),process.env.NO_PROXY=Ne.parse(process.env.RENOVATE_ENDPOINT).hostname);const t=process.env.NO_PROXY.split(",").filter(Boolean),r=Ne.parse(process.env.WS_CONTROLLER_DESTINATION_URL).hostname;t.includes(r)||(re.debug("Adding controller to NO_PROXY"),t.push(r)),process.env.REMEDIATE_SERVER_URL&&(re.debug("Adding remediate-server to NO_PROXY"),t.push(Ne.parse(process.env.REMEDIATE_SERVER_URL).hostname)),process.env.WS_REMEDIATE_SERVER_URL&&(re.debug("Adding remediate-server to NO_PROXY"),t.push(Ne.parse(process.env.WS_REMEDIATE_SERVER_URL).hostname)),process.env.NO_PROXY=t.join(","),re.info({HTTP_PROXY:process.env.HTTP_PROXY,HTTPS_PROXY:process.env.HTTPS_PROXY,NO_PROXY:process.env.NO_PROXY},"Initializing global proxy")}if(e.string(process.env.WS_HOST_RULES_PRIVATE_KEY))re.info("Detected  key for use in config decryption"),r.privateKey=Te(process.env.WS_HOST_RULES_PRIVATE_KEY);else if(e.string(process.env.WS_HOST_RULES_PRIVATE_KEY_FILE_PATH)){let e;try{e=await p.readFile(process.env.WS_HOST_RULES_PRIVATE_KEY_FILE_PATH,"utf8")}catch(e){re.warn({err:e,path:process.env.WS_HOST_RULES_PRIVATE_KEY_FILE_PATH},"Error reading private key from disk")}e?(re.info("Read PGP key from file"),r.privateKey=Te(e)):(re.error("Could not read private key - exiting"),process.exit())}else re.info("No GPG key"),delete process.env.RENOVATE_PRIVATE_KEY}catch(e){re.error({err:e},"Error retrieving Mend config"),process.exit()}return r}const Pe=R();function Ve(e){if(!e)return{};const t={};for(const r of Pe){const n=r.name;n in e&&(t[n]=e[n])}return t}let De;E(),De=["WS_ACTIVATION_KEY","GITHUB_APP_KEY",...(process.env.SANITIZE_ENV_KEYS??"").split(",").map(e=>e.trim()).filter(Boolean)];const Le=/<!-- <REMEDIATE>(.*?)<\/REMEDIATE>/;function xe(e){return!!e.body&&!!e.body.match(Le)}function Ue(e){const t=e.body.match(Le)[1];try{const r=JSON.parse(t);return r&&(Array.isArray(r)?r.forEach(t=>{null!==t.issueNumber&&void 0!==t.issueNumber||(t.issueNumber=e.number||e.iid||e.id)}):null!==r.issueNumber&&void 0!==r.issueNumber||(r.issueNumber=e.number||e.iid||e.id)),{number:e.number||e.iid||e.id,payload:r}}catch(t){re.error({issue:e},"Error parsing issue payload")}return null}function Me(e){if(Array.isArray(e.payload)){let t=!1;return e.payload.forEach(e=>{t=t||e.isPackageBased&&e.isOpenPROnVulnerability&&e.packages&&e.packages.length&&e.packages.some(e=>e.minimumFixVersion)}),!!t||(re.debug({issue:e},"Issue does not need remediation PR"),!1)}return!!(e.payload.isPackageBased&&e.payload.isOpenPROnVulnerability&&e.payload.packages&&e.payload.packages.length&&e.payload.packages.some(e=>e.minimumFixVersion))||(re.debug({issue:e},"Issue does not need remediation PR"),!1)}const Ce={GO:"go",Java:"maven","javascript/Node.js":"npm",Nuget:"nuget",PHP:"packagist",Python:"pypi",Ruby:"rubygems"},je={go:["gomod"],maven:["maven","gradle"],npm:["npm"],packagist:["composer"],nuget:["nuget"],pypi:["pip_requirements","pip_setup","pipenv","poetry"],rubygems:["bundler"]};function qe(e,t){return function(e){return"github"===e}(e)&&("github.com"===process.env.WS_PLATFORM||"enterprise"===process.env.WS_PLATFORM)&&t.enableReachability}function Fe(e){return function(e){return!0===e.reachabilityAnalyzed&&!0===e.reachable}(e)?"<p align=\"center\"><img src='https://whitesource-resources.whitesourcesoftware.com/viaRed.png' width=19 height=20> Reachable</p>":function(e){return!0===e.reachabilityAnalyzed&&!1===e.reachable}(e)?"<p align=\"center\"><img src='https://whitesource-resources.whitesourcesoftware.com/viaGreen.png' width=19 height=20> Unreachable</p>":""}function Ke(e,t){const r=e-t;return r>0?e+" (+"+r+"<a href=\"#\"><img src='https://whitesource-resources.whitesourcesoftware.com/red_arrow_up.png' width=19 height=20 title = 'Change in the number of vulnerabilities compared to the current version.'></a>)":r<0?e+" ("+r+"<a href=\"#\"> <img src='https://whitesource-resources.whitesourcesoftware.com/green_arrow_down.png' width=19 height=20 title = 'Change in the number of vulnerabilities compared to the current version.'></a>)":e+" (--)"}function Be(e,t){if(!t)return null;const r=(100*(e/t-1)).toFixed(0);return r>0?r+"% <a href=\"#\"><img src='https://whitesource-resources.whitesourcesoftware.com/red_arrow_up.png' width=19 height=20 title = 'The risk change compared to the current version.'></a>":r<0?r+"% <a href=\"#\"><img src='https://whitesource-resources.whitesourcesoftware.com/green_arrow_down.png' width=19 height=20 title = 'The risk change compared to the current version.'></a>":"0%"}function $e(e,t){let r=0,n=0,o=0,s=0;return e.vulnerabilities.forEach(e=>{e.score>=0&&e.score<4&&(r+=1),e.score>=4&&e.score<7&&(n+=1),e.score>=7&&e.score<9&&(o+=1),e.score>=9&&e.score<=10&&(s+=1)}),t?{lowSeverityCellValue:Ke(r,t.lowSeverityCellValue),mediumSeverityCellValue:Ke(n,t.mediumSeverityCellValue),highSeverityCellValue:Ke(o,t.highSeverityCellValue),criticalSeverityCellValue:Ke(s,t.criticalSeverityCellValue),riskChangeCellValue:Be(e.totalScore,t.totalScore)}:{lowSeverityCellValue:r,mediumSeverityCellValue:n,highSeverityCellValue:o,criticalSeverityCellValue:s,totalScore:e.totalScore}}function We(e,t,r){return"<details "+("latest"!==r&&"current"!==r?"open":"")+" >\n<summary>Version "+t+" "+{latest:"<a href=\"#\"><img src='https://whitesource-resources.whitesourcesoftware.com/latest.png' height=17></a>",current:"<a href=\"#\"><img src='https://whitesource-resources.whitesourcesoftware.com/current.png' height=17></a>",suggested:"<a href=\"#\"><img src='https://whitesource-resources.whitesourcesoftware.com/recommended_fix.png' height=17></a>",latestSuggested:"<a href=\"#\"><img src='https://whitesource-resources.whitesourcesoftware.com/latest.png' height='17'>  <img src='https://whitesource-resources.whitesourcesoftware.com/recommended_fix.png' height='17'></a>"}[r]+" </summary> \n\n| Risk Change <a href=\"#\"><img src='https://whitesource-resources.whitesourcesoftware.com/info_icon.png' width=19 height=20 title = 'Risk Change is calculated by our algorithm based on the numbers and severities of vulnerabilities'></a>|<a href=\"#\"><img src='https://whitesource-resources.whitesourcesoftware.com/critical_vul.png?' width=19 height=20></a> Critical |<a href=\"#\"><img src='https://whitesource-resources.whitesourcesoftware.com/high_vul.png?' width=19 height=20></a> High |<a href=\"#\"><img src='https://whitesource-resources.whitesourcesoftware.com/medium_vul.png?' width=19 height=20></a> Medium | <a href=\"#\"><img src='https://whitesource-resources.whitesourcesoftware.com/low_vul.png?' width=19 height=20></a> Low | \n| --- | --- | --- | --- | --- |\n| "+(e.riskChangeCellValue||"N/A")+" | "+e.criticalSeverityCellValue+" | "+e.highSeverityCellValue+" | "+e.mediumSeverityCellValue+" | "+e.lowSeverityCellValue+" |\n</details>\n\n"}function Ge(e){return e}async function He(e,t){re.debug("Retrieving issues list from Bitbucket API");const r=h(process.env.RENOVATE_ENDPOINT,`/plugins/servlet/whitesource/repository/${t}/build/report`);try{const e={requestType:"getIssues"},t=global.bitbucketUseBasicAuth?{Authorization:`Basic ${Buffer.from(`${process.env.RENOVATE_USERNAME}:${process.env.RENOVATE_PASSWORD}`).toString("base64")}`}:{Authorization:`Bearer ${process.env.RENOVATE_PASSWORD}`};return await n.post(r,{json:e,headers:t}).json()}catch(e){return re.error({err:e,url:r},"Could not retrieve Bitbucket issues"),[]}}function Ye(e){for(const t of e)t.prBodyNotes&&(t.prBodyNotes[0]=t.prBodyNotes[0].replace(/<a.*?<\/a>/g,""));return e}function Je(e){return e}const ze=new T;async function Xe(e,t){re.debug("Retrieving issues list from GitHub API");const r=h(process.env.RENOVATE_ENDPOINT,`repos/${t}/issues?state=open&per_page=100`),n={paginate:!0,useCache:!1};let o=[];try{o=(await ze.getJsonUnchecked(r,n)).body}catch(e){re.debug("Repository has issues disabled"),re.trace({err:e,url:r},"Cannot fetch repository issues")}return o}function Qe(e){return e}const Ze=new _;async function et(e,t){const r=h(process.env.RENOVATE_ENDPOINT,`projects/${t.replace(/\//g,"%2f")}/issues?state=opened`);re.debug({url:r},"Retrieving issues list from GitLab API");const n={paginate:!0,useCache:!1};let o=[];try{o=(await Ze.getJsonUnchecked(r,n)).body,o=o.map(e=>{const t={...e};return t.body=t.description,delete t.description,t})}catch(e){re.info({err:e,url:r},"Error retrieving issues list")}return o}function tt(e){return e}const rt={go:O.get("semver"),maven:O.get("maven"),npm:O.get("npm"),packagist:O.get("composer"),nuget:O.get("nuget"),pypi:O.get("pep440"),rubygems:O.get("ruby")};function nt(e,t,r){const n="pypi"===r?new RegExp(`${t}\\s*(-|:)\\s*`,"i"):new RegExp(`${t}\\s*(-|:)\\s*`);return e.replace(n,"")}function ot(e,t){return t.libraryData.libraryFixVersion=e,"\x3c!--[REMEDIATE_ANALITICS]"+JSON.stringify(t)+"[/REMEDIATE_ANALITICS]--\x3e"}function st(e,t){const{minimumFixVersions:r,packageName:n,packageVersion:o,prBodyNote:s,kpiData:i}=e,a=rt[t];if(!a.isVersion(o))return void re.warn({details:e},"Invalid packageVersion, cannot compare/upgrade");const c=function(e,t,r,n,o){let s=null;for(const i of e){const e=at(i,t,r,n,o);if(!e.length){re.info({packageName:r},"No valid greaterThanFixVersions");continue}const a=e[0];s&&!n.isGreaterThan(a,s)||(s=a)}return s}(r,o,n,a,t);if(!c)return void re.info("No valid minimumFixVersion found");const u=function(e,t,r){let n="maven"===e?`[${t},)`:`>= ${t}`;if(!r.isValid(n)&&!rt.npm.isValid(n)){if(!r.isValid(t)&&!rt.npm.isValid(t))return re.warn({datasource:e,minimumFixVersion:t},"Invalid allowedVersions"),null;re.info({datasource:e,minimumFixVersion:t},"Falling back to single allowedVersions"),n=t}return n}(t,c,a);return u?{allowedVersions:u,prBodyNote:s,kpiData:i,packageVersion:o,packageName:n,minimumFixVersion:c}:void 0}function it(e,t){return{datasource:e,depName:t.packageName,currentVersion:t.packageVersion,newVersion:t.minimumFixVersion,prBodyNotes:[t.prBodyNote],commitMessageSuffix:""}}function at(e,t,r,n,o){const s=e.split(",").map(e=>e.trim()).map(e=>function(e,t,r){let n=nt(e,t,r);const o=t.replace(/^.*?\/(.*?)(\..*)?$/,"$1");return o&&(n=nt(n,o,r)),n!==e&&re.debug({original:e,res:n},"Massaged fixed-in version string"),n}(e,r,o)),i=("npm"===o?s.map(e=>N.coerce(e).version):s).filter(e=>n.isVersion(e));return[...new Set(i)].filter(e=>n.isGreaterThan(e,t)).sort(n.sortVersions)}function ct(e,t,r){const{allowedVersions:n,prBodyNote:o,kpiData:s,packageVersion:i,packageName:a,minimumFixVersion:c}=r,u=function(e,t,r){return"github.com"===process.env.WS_PLATFORM?[e+ot(t,r)]:[e]}(o,c,s),l=function(e,t){return"pypi"===e?`==${t}`:t}(e,i),p=[a];a!==a.toLowerCase()&&p.push(a.toLowerCase());const d={matchDatasources:[e],matchPackageNames:p,matchCurrentVersion:l,allowedVersions:n,vulnerabilityAlert:!0,enabled:!0,ignoreUnstable:!1,groupName:null,schedule:[],dependencyDashboardApproval:!1,labels:["security fix"],prBodyTemplate:"{{{table}}}{{{notes}}}{{{changelogs}}}{{{controls}}}",prBodyNotes:u,isVulnerabilityAlert:!0,commitMessageSuffix:"",suppressNotifications:["prIgnoreNotification","prEditNotification"]};return"*"!==t&&t.endsWith("package.json")&&(d.matchFileNames=[t]),"npm"===e&&(d.rangeStrategy="update-lockfile"),d}const ut={"bitbucket-server":K,github:$,gitlab:W,azure:F,bitbucket:B};async function lt(t,r){const o=process.env.RENOVATE_PLATFORM,s=r.repository,i=await async function(e,t){if(process.env.REMEDIATE_LOCAL_DEV)return{};if("bitbucket-server"===process.env.WS_PLATFORM)return{shouldQueryIssues:!0};const r=t.repository;let o;if("azure"===process.env.RENOVATE_PLATFORM)o={},o.id=t.params.repoId,o.accountId=t.params.accountId,o.installationId=t.params.collectionId,o.repositoryName=r;else if("bitbucket"===process.env.RENOVATE_PLATFORM)o={},o.id=t.params.repoId,o.accountId=t.params.accountId,o.installationId=t.installationId,o.repositoryName=r;else{global.repoVerboseList=global.repoVerboseList||[];let e=global.repoVerboseList.find(e=>e.repository===r);if(!e&&(e=await async function(e,t){try{if("gitlab"===process.env.RENOVATE_PLATFORM){const r=e.replaceAll("/","%2F"),o=h(process.env.RENOVATE_ENDPOINT,"projects/"+r);re.info(o);const s={headers:{"PRIVATE-TOKEN":process.env.RENOVATE_TOKEN},timeout:{request:1e4}},i=await n(o,s).json();if(i&&i.namespace){const e={repository:i.path_with_namespace,id:i.id,accountId:i.namespace.id,accountType:i.namespace.kind,installationId:t};return global.repoVerboseList.push(e),e}}else if("github"===process.env.RENOVATE_PLATFORM){const r=h(process.env.RENOVATE_ENDPOINT,"repos/"+e);re.info(r);const o={headers:{accept:"application/vnd.github.machine-man-preview+json",authorization:`Bearer ${process.env.RENOVATE_TOKEN}`,timeout:{request:1e4}}},s=await n(r,o).json();if(s&&s.owner){const e={repository:s.full_name,id:s.id,accountId:s.owner.id,installationId:t};return global.repoVerboseList.push(e),e}}}catch(e){e.statusCode&&e.statusCode>=500&&e.statusCode<600?re.warn({err:e},"Error reaching SCM API. Unable to get project verbose data."):re.warn({err:e,message:e.message},"Unknown API error")}return null}(r,t.installationId),!e))return re.debug({matchedRepo:e},"Unable to get repository data to get issuses from"),{shouldQueryIssues:!0};o=e}let s=`repoId=${o.id}&accountId=${o.accountId}&installationId=${o.installationId}&repoName=${r}`;o.accountType&&(s+=`&accountType=${o.accountType}`);const i=h(process.env.WS_CONTROLLER_DESTINATION_URL||process.env.CONTROLLER_DESTINATION_URL,"remediate?"+s);re.debug({url:i},"Retrieving issues list from Controller API");const a={timeout:{request:3e4}},c=X(i);c&&(a.headers={[c.name]:c.value});const u=await n(i,a).json();if(!u)return re.debug({url:i},"No issues provided by the controller. Fallback to getting issues from scm provider"),{shouldQueryIssues:!0};let l;if(u.mcJwt&&(re.debug(`${r} has retrieved mcJwt successfully`),l=u.mcJwt),u.shouldQueryIssues)return re.debug("Issues should be retrieved directly from the scm provider"),{issues:u,mcJwt:l};if(!u.remediation)return re.info("No issues from controller"),{mcJwt:l};const p=[];return u.remediation.forEach(e=>{e.isPackageBased=e.isPackageBased||e.packageBased,e.isDefaultBranch=e.isDefaultBranch||e.defaultBranch,e.isOpenPROnVulnerability=e.isOpenPROnVulnerability||e.openPROnVulnerability,e.packages.forEach(e=>{e.isTransitiveDependency=e.isTransitiveDependency||e.transitiveDependency,e.isMinimumFixVersionAvailable=e.isMinimumFixVersionAvailable||e.minimumFixVersionAvailable});const t=null!==e.issueNumber&&void 0!==e.issueNumber?e.issueNumber:-1,r={body:"\x3c!-- <REMEDIATE>"+JSON.stringify(e)+"</REMEDIATE>",id:t};p.push(r)}),{issues:p,mcJwt:l}}(0,r);let a=i.issues;const c=i.mcJwt;let u=[];if(i&&i.shouldQueryIssues&&(a=await ut[o].fetchIssues(t,s)),u=function(e){if(!e)return[];re.trace({issues:e},"Open issues"),re.debug({count:e.length},"Open issues");let t=e.filter(xe);return t.length?(re.debug({count:t.length},"Issues with REMEDIATE JSON"),t=t.map(Ue).filter(Boolean),t.length?(re.debug({count:t.length},"Issues with parsed REMEDIATE JSON"),t=t.filter(Me),re.debug({count:t.length},"Issues needing remediation"),t):[]):[]}(a),!u.length)return{mcJwt:c};re.debug({issues:u},"Found Remediate Issues");const l=function(e){const t=[],r={};for(const[n,o]of Object.entries(e))for(const[e,s]of Object.entries(o)){re.debug({datasource:e,packages:s},"Processing datasource");for(const o of Object.values(s))try{const s=st(o,e);if(o.isTransitiveDependency){const t=n.replace(/package.json$/,"package-lock.json");r[t]=r[t]||[];const o=it(e,s);r[t].push(o)}else{const r=ct(e,n,s);if(t.push(r),"pypi"===e){const e={...r};e.matchManagers=["poetry"],e.matchCurrentVersion=s.packageVersion,t.push(e)}}}catch(t){re.error({datasource:e,package:o,err:t},"error building remediation for package")}}return re.debug({packageRules:t}),{packageRules:t,remediations:r}}(function(t,r,n){const o={},s="DEPENDENCY"===n.issueSettings.issueType;let i=t.map(e=>e.payload);t.length>0&&Array.isArray(t[0].payload)&&(i=i.flat());const a="bitbucket-server"!==r&&t.some(e=>-1!==e.number);return i.sort((e,t)=>{const r=e.cvss3Score||e.cvss2Score,n=t.cvss3Score||t.cvss2Score;return r===n?e.vulnerabilityIdentifier.localeCompare(t.vulnerabilityIdentifier):parseFloat(n)-parseFloat(r)}),i.forEach(t=>{n.leastVulnerablePackageSettings&&n.leastVulnerablePackageSettings.enabled&&t.packages.length>0&&t.packages[0].currentVersionVulnerabilities?function(t,r,n,o){if(re.debug("Processing issue number "+n.issueNumber),re.trace({item:n},"issue payload"),n.isOpenPROnVulnerability&&n.isPackageBased&&n.isDefaultBranch)for(const t of n.packages){const{isTransitiveDependency:r}=t;if(!0===r){re.debug("Skipping transitive dependency");continue}if(!0!==t.isMinimumFixVersionAvailable){re.debug("Skipping package with isMinimumFixVersionAvailable !== true");continue}if(!t.packageType){re.warn("Skipping package with no packageType");continue}if(!t.packageName){re.warn("Skipping package with no packageName");continue}if(!t.packageVersion){re.warn("Skipping package with no packageVersion");continue}if(["JavaScript"].includes(t.packageType))continue;const s=Ce[t.packageType];if(s){t.packageFilePaths&&t.packageFilePaths.length&&t.packageFilePaths.every(t=>e.nonEmptyString(t))||(t.packageFilePaths=["*"]);for(const e of t.packageFilePaths.filter(Boolean)){const i=e.replace(/^\//,"");o[i]||(o[i]={}),o[i][s]||(o[i][s]={});let{packageName:a,packageVersion:c}=t;t.groupId&&(a=t.groupId+":"+a),c.includes(",")&&(re.warn("Multiple packageVersion values found - using the first"),c=c.split(",")[0]);const u=`${a}@${c}`;if(re.trace(`Grouping based on ${s}/${u}`),!o[i][s][u]){const e=$e(t.currentVersionVulnerabilities,null),l=$e(t.suggestedVersionVulnerabilities,e),p=$e(t.latestVersionVulnerabilities,e);let d="#### This PR resolves the vulnerabilities described in Issue #"+n.issueNumber+"\n---\n\n";const g=t.suggestedVersionVulnerabilities.version===t.latestVersionVulnerabilities.version?"latestSuggested":"suggested";d+=We(e,t.currentVersionVulnerabilities.version,"current"),d+=We(l,t.suggestedVersionVulnerabilities.version,g),t.suggestedVersionVulnerabilities.version!==t.latestVersionVulnerabilities.version&&(d+=We(p,t.latestVersionVulnerabilities.version,"latest")),d+='#### Mend ensures you have the greatest risk reduction ("Recommended Fix"-highlighted in green) by removing as many vulnerabilities as possible. Click to see [how we calculate risk reduction](https://docs.mend.io/bundle/integrations/page/least_vulnerable_packages_feature.html).',o[i][s][u]={packageName:a,packageVersion:c,issues:[],minimumFixVersions:[],prBodyNote:d,isTransitiveDependency:r,isLeastVulnerablePackageEnabled:!0,kpiData:{libraryData:{libraryName:t.packageName,libraryVersion:t.packageVersion,libraryFixVersion:t.minimumFixVersion,libraryArtifactId:t.packageName,libraryGroupId:t.groupId,language:t.packageType},vulnerabilityData:[]}}}if(n.issueNumber&&!o[i][s][u].issues.includes(n.issueNumber)&&o[i][s][u].issues.push(n.issueNumber),!t.minimumFixVersion){re.warn({pkg:t},"No minimumFixVersion");continue}const l=t.minimumFixVersion.split(";");let p;o[i][s][u].minimumFixVersions=l;const d=n.cvss3Score||n.cvss2Score;n.cvss3Severity?p=n.cvss3Severity[0].toUpperCase()+n.cvss3Severity.slice(1):n.cvss2Severity?p=n.cvss2Severity[0].toUpperCase()+n.cvss2Severity.slice(1):re.warn("No CVSS2 or CVSS3 severity found in issue"),o[i][s][u].kpiData.vulnerabilityData.push({severity:p,score:d,vulnerabilityId:n.vulnerabilityIdentifier}),o[i][s][u].prBodyNote+="\n"}}else re.warn({pkg:t},"packageType is not known to Remediate - skipping")}else re.trace({isOpenPROnVulnerability:n.isOpenPROnVulnerability,isPackageBased:n.isPackageBased,isDefaultBranch:n.isDefaultBranch},"Skipping issue because of a false field in the meta data.")}(0,n.transitiveRemediation,t,o):function(t,r,n,o,s,i){if(re.debug("Processing issue number "+n.issueNumber),re.trace({item:n},"issue payload"),n.isOpenPROnVulnerability&&n.isPackageBased&&n.isDefaultBranch)for(const a of n.packages){const{isTransitiveDependency:c}=a;if(!0===c&&("javascript/Node.js"!==a.packageType||!r.transitiveRemediation)){re.debug("Skipping transitive dependency");continue}if(!0!==a.isMinimumFixVersionAvailable){re.debug("Skipping package with isMinimumFixVersionAvailable !== true");continue}if(!a.packageType){re.warn("Skipping package with no packageType");continue}if(!a.packageName){re.warn("Skipping package with no packageName");continue}if(!a.packageVersion){re.warn("Skipping package with no packageVersion");continue}if(["JavaScript"].includes(a.packageType))continue;const u=Ce[a.packageType];if(u){a.packageFilePaths&&a.packageFilePaths.length&&a.packageFilePaths.every(t=>e.nonEmptyString(t))||(a.packageFilePaths=["*"]);for(const e of a.packageFilePaths.filter(Boolean)){const l=e.replace(/^\//,"");o[l]||(o[l]={}),o[l][u]||(o[l][u]={});let{packageName:p,packageVersion:d}=a;a.groupId&&(p=a.groupId+":"+p),d.includes(",")&&(re.warn("Multiple packageVersion values found - using the first"),d=d.split(",")[0]);const g=`${p}@${d}`;re.trace(`Grouping based on ${u}/${g}`);const f=s&&!i,m=qe(t,r);if(!o[l][u][g]){let e="By merging this PR, the below vulnerabilities will be automatically resolved:\n\n";f&&(e="By merging this PR, the below issues will be automatically resolved and closed:\n\n"),s&&i&&n.issueNumber&&-1!==n.issueNumber&&(e=`By merging this PR, the issue #${n.issueNumber} will be automatically resolved and closed:\n\n`),e+="| Severity           ","bitbucket"===process.env.WS_PLATFORM?e+="| ðŸŽ¯ CVSS Score       ":e+="| <a href='#'><img src='https://whitesource-resources.whitesourcesoftware.com/cvss3.png' width='19' height='20'></a> CVSS Score       ",e+="|Vulnerability  |",m&&(e+=" Reachability |"),f&&("bitbucket"===process.env.WS_PLATFORM?e+=" Issue |":e+=" GitHub Issue |"),e+=f?"\n|---|---|---|---|":"\n|---|---|---|",m&&(e+="---|"),e+="\n","gitlab"===t&&(e=e.replace(/GitHub/g,"GitLab").replace(/PR/g,"MR")),"azure"===t&&(e=e.replace(/GitHub/g,"Azure").replace(/Issue/g,"Work Item")),o[l][u][g]={packageName:p,packageVersion:d,issues:[],minimumFixVersions:[],prBodyNote:e,isTransitiveDependency:c,kpiData:{libraryData:{libraryName:a.packageName,libraryVersion:a.packageVersion,libraryFixVersion:a.minimumFixVersion,libraryArtifactId:a.packageName,libraryGroupId:a.groupId,language:a.packageType},vulnerabilityData:[]}}}if(n.issueNumber&&!o[l][u][g].issues.includes(n.issueNumber)&&o[l][u][g].issues.push(n.issueNumber),!a.minimumFixVersion){re.warn({pkg:a},"No minimumFixVersion");continue}let h;a.minimumFixVersion.split(";").forEach(e=>{o[l][u][g].minimumFixVersions.includes(e)||o[l][u][g].minimumFixVersions.push(e)});const b=n.cvss3Score||n.cvss2Score;n.cvss3Severity?h=n.cvss3Severity[0].toUpperCase()+n.cvss3Severity.slice(1):n.cvss2Severity?h=n.cvss2Severity[0].toUpperCase()+n.cvss2Severity.slice(1):re.warn("No CVSS2 or CVSS3 severity found in issue");let y="";if("bitbucket-server"===t&&(y="{width=20 height=20}"),o[l][u][g].prBodyNote+="bitbucket"===t?"|":f?`| <a href='#'><img src='https://whitesource-resources.whitesourcesoftware.com/${h.toLowerCase()}_vul.png?' width='19' height='20'></a>`:`| ![${h}](https://whitesource-resources.whitesourcesoftware.com/${h.toLowerCase()}_vul_bb.png?)${y}`,o[l][u][g].prBodyNote+=` ${h} | ${b} | [${n.vulnerabilityIdentifier}](${n.vulnerabilityUrl}) |`,m){const e=Fe(n);o[l][u][g].prBodyNote+=` ${e} |`}o[l][u][g].kpiData.vulnerabilityData.push({severity:h,score:b,vulnerabilityId:n.vulnerabilityIdentifier}),f&&(o[l][u][g].prBodyNote+=` #${n.issueNumber} |`),o[l][u][g].prBodyNote+="\n"}}else re.warn({pkg:a},"packageType is not known to Remediate - skipping")}else re.trace({isOpenPROnVulnerability:n.isOpenPROnVulnerability,isPackageBased:n.isPackageBased,isDefaultBranch:n.isDefaultBranch},"Skipping issue because of a false field in the meta data.")}(r,n,t,o,a,s)}),o}(u,o,t));return{cveConfig:{packageRules:ut[o].massagePackageRules(l.packageRules),remediations:l.remediations},mcJwt:c}}async function pt(e,t){let r;try{r=await async function(e,t){if(re.debug("Retrieving repo configuration from controller"),process.env.REMEDIATE_LOCAL_DEV)return oe("DUMMY_REPO_SETTINGS")||JSON.parse(JSON.stringify(ne));const r=e.split("/"),o=r.pop();let s=`owner=${r.join("/")}&repository=${o}`;t&&(s+=`&installationId=${t}`),process.env.WS_CONTROLLER_DESTINATION_URL=process.env.WS_CONTROLLER_DESTINATION_URL||process.env.CONTROLLER_DESTINATION_URL||process.env.BOLT_SERVER_DESTINATION_URL;const i=h(process.env.WS_CONTROLLER_DESTINATION_URL,"/remediate/getRepoSettings?"+s),a={timeout:{request:1e4}},c=X(i);c&&(a.headers={[c.name]:c.value});let u={};try{u=await n(i,a).json()}catch(e){re.error({err:e,url:i},"Error retrieving repo configuration from the controller")}return u}(e,t),re.debug({config:r},"Repo config from controller")}catch(e){return void re.warn({err:e},"Error fetching .whitesource from controller")}if(!r||"{}"===JSON.stringify(r))return void re.info("Repository is not installed or onboarded");const o={};return r.hostRules&&(o.hostRules=r.hostRules,o.packageRules=function(e){if(process.env.REMEDIATE_SKIP_DATASOURCE_REDIRECT)return[];const t=["maven","gradle","pip","pipenv","nuget"],r={};e.forEach(e=>{const{hostType:n,matchHost:o}=e;t.includes(n)&&(re.debug(`Adding ${o} to default registryUrls for datasource=${n}`),r[n]=r[n]||[],r[n].push(o))});const n=[];for(const[e,t]of Object.entries(r))n.push({matchDatasources:[e],registryUrls:t});return re.debug({hostRules:e,packageRules:n},"Autogenerated registryUrls packageRules from hostRules"),n}(r.hostRules)),r.scanSettings&&r.scanSettings.baseBranches&&r.scanSettings.baseBranches.length&&(o.baseBranchPatterns=r.scanSettings.baseBranches),r.scanSettings&&r.scanSettings.enableReachability&&(o.enableReachability=r.scanSettings.enableReachability),r.issueSettings&&r.issueSettings.issueType?o.issueSettings={issueType:r.issueSettings.issueType}:o.issueSettings={issueType:"VULNERABILITY"},r.remediateSettings&&Object.assign(o,r.remediateSettings),r.leastVulnerablePackageSettings&&Object.assign(o,{leastVulnerablePackageSettings:r.leastVulnerablePackageSettings}),o.hostRules&&(o.hostRules=o.hostRules.map(e=>{const t={...e};return e.userName&&(re.debug("Massaging hostRules userName to username"),t.username=e.userName,delete t.userName),delete t.envVariablesMapping,delete t.sourceName,t})),o}const dt=async function(){let e;return process.env.WEBHOOK_SECRET="null","true"===process.env.REMEDIATE_SERVER_ONLY||"true"===process.env.WS_REMEDIATE_SERVER_ONLY?global.remediateServerOnly=!0:process.env.REMEDIATE_SERVER_URL?global.remediateServerUrl=process.env.REMEDIATE_SERVER_URL:process.env.WS_REMEDIATE_SERVER_URL&&(global.remediateServerUrl=process.env.WS_REMEDIATE_SERVER_URL),"github.com"===process.env.WS_PLATFORM?e=await async function(){re.info("Initializing Mend Remediate for GitHub.com config");const e={platform:"github",endpoint:"https://api.github.com/"};if(process.env.REMEDIATE_LOCAL_DEV)return e;try{const e=Oe(),t=(await e.getSecret(process.env.GH_APP_AZURE_KEYVAULT_SECRET)).value;re.trace({rawKey:t},"rawKey"),process.env.GITHUB_APP_KEY=t.replace(/ /g,"\n").replace(/\nRSA/g," RSA").replace(/\nPRIVATE/g," PRIVATE").replace(/\nKEY/g," KEY"),re.info("Retrieved GitHub App Key from Vault"),re.trace("massaged key = "+process.env.GITHUB_APP_KEY)}catch(e){re.error({err:e},"Error retrieving GitHub App key from Vault"),process.exit()}const t=await _e();return t&&(e.privateKey=t),e}():"azure"===process.env.WS_PLATFORM?e=await async function(){return re.info("Initializing Mend Remediate for dev.azure.com config"),{platform:"azure",endpoint:"https://dev.azure.com/",privateKey:await _e()}}():"bitbucket"===process.env.WS_PLATFORM?e=await async function(){return re.info("Initializing Mend Remediate for bitbucket.org config"),{platform:"bitbucket",endpoint:"https://api.bitbucket.org/",privateKey:await _e()}}():"enterprise"===process.env.WS_PLATFORM&&(e=await Ie()),e},gt=async function(e,t,r){t||(t={});const n=JSON.parse(JSON.stringify(r));t.RENOVATE_PLATFORM?n.platform=t.RENOVATE_PLATFORM:n.platform=process.env.RENOVATE_PLATFORM,t.RENOVATE_ENDPOINT?n.endpoint=t.RENOVATE_ENDPOINT:n.endpoint=process.env.RENOVATE_ENDPOINT,t.RENOVATE_USERNAME?n.username=t.RENOVATE_USERNAME:n.username=global.renovateUsername,t.RENOVATE_TOKEN&&(n.token=t.RENOVATE_TOKEN),t.RENOVATE_GIT_AUTHOR&&(n.gitAuthor=t.RENOVATE_GIT_AUTHOR),process.env.RENOVATE_PASSWORD&&(n.password=process.env.RENOVATE_PASSWORD),n.repositories=[e];const o="true"===process.env.RENOVATE_ONBOARDING,s={autodiscover:!1,branchPrefix:"whitesource-remediate/",cacheDir:"/tmp/renovate/cache",containerbaseDir:"/tmp/renovate/containerbase",forkProcessing:"enabled",onboarding:o,platformCommit:"disabled",prFooter:"",requireConfig:o?"required":"optional",suppressNotifications:["missingCredentialsError"],vulnerabilityAlerts:{enabled:!1,ignoreUnstable:!1,groupName:null,schedule:[],dependencyDashboardApproval:!1,labels:["security fix"],commitMessageSuffix:""}};return await p.ensureDir(s.cacheDir),await p.ensureDir(s.containerbaseDir),{...n,...s}},ft=async function(e,t){const r=e.repository;re.debug({repository:r},"Retrieving remediate repository config");try{let o=await pt(r,t);if(!o)return re.debug("No config - skipping repository"),{};o=function(e){if(!e)return{};const t={...e};for(const r of Pe)!0===r.globalOnly&&e[r.name]&&delete t[r.name];return t}(o);let s,i,a="remediation-only"===(n=o).renovateStrategy||"full"===n.renovateStrategy||"disabled"===n.renovateStrategy?n:!0===n.enableRenovate||"true"===n.enableRenovate?(delete n.enableRenovate,n.renovateStrategy="full",n):!1===n.enableRenovate||"false"===n.enableRenovate?(delete n.enableRenovate,n.renovateStrategy="remediation-only",n):(n.enableRenovate&&delete n.enableRenovate,n.renovateStrategy="remediation-only",n);if("disabled"===a.renovateStrategy||!1===a.enabled)return re.info({config:a},"Repository is disabled by config"),a.enabled=!1,a;try{const t=await lt(a,e);s=t.cveConfig,i=t.mcJwt}catch(e){return re.error({err:e},"Error getting issues - aborting repo job"),{}}return function(e,t){if(t.enabledManagers)return;if("full"===t.renovateStrategy)return void delete t.enabledManagers;if(!e)return void(t.enabledManagers=[]);const r=[],n=e.packageRules;if(n.length)for(const e of n)if(e.matchDatasources&&e.matchDatasources.length){const t=e.matchDatasources[0];for(const e of je[t])r.includes(e)||r.push(e)}t.enabledManagers=r}(s,a),a=v(a,s),"full"===a.renovateStrategy?(delete a.renovateStrategy,re.info({config:a},"Repository has PR updates enabled")):function(e,t){return"disabled"===t.renovateStrategy||"scheduled"===e.reason&&t.enabledManagers&&1===t.enabledManagers.length&&""===t.enabledManagers[0]}(e,a)?(re.debug({config:a},"Skipping repository"),a.enabled=!1):(a.packageRules||(a.packageRules=[],re.debug({config:a},"Allowing remediating repository to close any open pull requests that may be stale")),a.packageRules.unshift({matchPackageNames:["*"],enabled:!1}),re.info({config:a},"Repository is in remediate-only mode")),{config:a,mcJwt:i}}catch(e){return re.error({err:e},"getRepoConfig error"),{config:{repository:r,enabled:!1}}}var n};let mt,ht,bt,yt,vt,Et,Rt=null;function Tt(e,t,r){yt=e,vt=t,Et=r}function _t(e=300){const t={iss:vt},r={expiresIn:e,algorithm:"RS256"};return b.sign(t,Et,r)}async function Ot(){re.info("Validating inputs"),process.env.RENOVATE_PLATFORM||(re.error("Missing configuration: RENOVATE_PLATFORM"),process.exit(0)),process.env.RENOVATE_ENDPOINT||(re.error("You must configure RENOVATE_ENDPOINT"),process.exit(0)),process.env.RENOVATE_ENDPOINT=process.env.RENOVATE_ENDPOINT.replace(/[^/]$/,"$&/"),re.info(`Trying ${process.env.RENOVATE_PLATFORM} platform: ${process.env.RENOVATE_ENDPOINT}`),"github"===process.env.RENOVATE_PLATFORM?await async function(){if(re.info(`Using GitHub endpoint: ${process.env.RENOVATE_ENDPOINT}`),process.env.GITHUB_APP_ID||(re.error("You must set GITHUB_APP_ID"),process.exit(0)),!process.env.GITHUB_APP_KEY){re.info("GITHUB_APP_KEY not set - attempting to read pem file from disk");let e="";try{e=Se.readFileSync("/usr/src/app/renovate.private-key.pem","utf8")}catch(e){re.debug({err:e,message:e.message},"err reading pemfile")}e&&e.length?(process.env.GITHUB_APP_KEY=e,re.info("Read private key from disk")):(re.error("You must provide a GitHub App Key via GITHUB_APP_KEY or pem file"),process.exit(0))}process.env.RENOVATE_TOKEN&&(re.warn("You should not configure GITHUB_TOKEN or RENOVATE_TOKEN if using Renovate in GHE App mode. It will be ignored."),delete process.env.RENOVATE_TOKEN);const e=process.env.GITHUB_APP_ID,t=process.env.GITHUB_APP_KEY.replace(/\\n/g,"\n");Tt(process.env.RENOVATE_ENDPOINT,e,t);const r=`${process.env.RENOVATE_ENDPOINT}app`,o={headers:{accept:"application/vnd.github.machine-man-preview+json",authorization:`Bearer ${_t()}`}};try{const e=await n(r,o).json();re.trace({res:e}),re.info(`Authenticated as GitHub app: ${e.name}`);const t=(e.slug||e.name.toLowerCase().replace(/\s/g,"-").replace(/\./g,"-").replace(/-+/g,"-"))+"[bot]";global.botUsername=t,global.renovateUsername=t;const s=function(e){const t=Ne.parse(e),r=`${t.path.split("/").pop()}[bot]@users.noreply.${t.hostname}`;return re.info({email:r},"Email configured"),r}(e.html_url);re.info({username:t,email:s},"Platform username/email"),global.gitAuthor=`${t} <${s}>`}catch(e){re.error({err:e,body:e.response?e.response.body:void 0},"GitHub App ID/Key is not accepted"),process.exit(0)}}():"gitlab"===process.env.RENOVATE_PLATFORM?await async function(){re.info(`Using GitLab endpoint: ${process.env.RENOVATE_ENDPOINT}`),process.env.RENOVATE_TOKEN||(re.error("You need to configure RENOVATE_TOKEN for your bot account"),process.exit(0));try{const e=Ne.resolve(process.env.RENOVATE_ENDPOINT,"user"),t={headers:{"PRIVATE-TOKEN":process.env.RENOVATE_TOKEN}},r=await n(e,t).json();re.debug({user:r}),re.info(`Authenticated as GitLab user: ${r.username}`),global.botUsername=r.username,global.botUserId=r.id,global.gitAuthor=`${r.name} <${r.email}>`,await A({endpoint:process.env.RENOVATE_ENDPOINT,token:process.env.RENOVATE_TOKEN})}catch(e){re.error({err:e,body:e.response?e.response.body:void 0},"GitLab authentication failed"),process.exit(0)}}():"bitbucket-server"===process.env.RENOVATE_PLATFORM?await async function(){re.info(`Using Bitbucket Server endpoint: ${process.env.RENOVATE_ENDPOINT}`),process.env.RENOVATE_USERNAME&&process.env.RENOVATE_PASSWORD||(re.error("You need to configure RENOVATE_USERNAME and RENOVATE_PASSWORD for your bot account"),process.exit(0));try{const t=(e=`${process.env.RENOVATE_USERNAME}:${process.env.RENOVATE_PASSWORD}`,Buffer.from(e,"binary").toString("base64"));process.env.BBTOKEN=t;const r=Ne.resolve(process.env.RENOVATE_ENDPOINT,`./rest/api/1.0/users/${process.env.RENOVATE_USERNAME}`),o={headers:{Authorization:`Basic ${t}`}},s=await n(r,o).json();re.debug({user:s}),re.info(`Authenticated as Bitbucket user: ${process.env.RENOVATE_USERNAME}`),await k({endpoint:process.env.RENOVATE_ENDPOINT,username:process.env.RENOVATE_USERNAME,password:process.env.RENOVATE_PASSWORD}),global.botUsername=s.name,global.botUserId=s.id,process.env.RENOVATE_GIT_AUTHOR=process.env.RENOVATE_GIT_AUTHOR||`${s.displayName} <${s.emailAddress}>`,global.gitAuthor=process.env.RENOVATE_GIT_AUTHOR,await async function(e,t){const r={encoding:"utf-8",stdio:"inherit",env:{...process.env},maxBuffer:1/0};await w(`git config --global user.email "${t}"`,r),await w(`git config --global user.name "${e}"`,r)}(s.displayName,s.emailAddress)}catch(e){re.error({err:e,body:e.response?e.response.body:void 0},"Bitbucket Server authentication failed"),process.exit(0)}var e}():"bitbucket"===process.env.RENOVATE_PLATFORM?re.info("Remediate does not need inputs validated for Bitbucket"):"azure"===process.env.RENOVATE_PLATFORM?re.info("Remediate does not need inputs validated for Azure"):(re.error("Unknown platform: "+process.env.RENOVATE_PLATFORM),process.exit(0))}const Nt=["repo:commit_status_created"];function St(e,t,r){global.repoVerboseList=global.repoVerboseList||[],e.forEach(e=>{const n={repository:e.full_name,id:e.id,accountId:t,installationId:r};global.repoVerboseList.push(n)})}function kt(e,t){function r(e){t.status(400).send({error:e})}const n=e.body;if(re.trace({payload:n},"Event payload"),!e.headers["x-github-delivery"])return r("No id found in the request");const o=e.headers["x-github-event"];if(!o)return r("No event found in the request");if("null"!==process.env.WEBHOOK_SECRET){const t=e.headers["x-hub-signature"]||"";if(!t)return r("No signature found in the request");if(s=process.env.WEBHOOK_SECRET||"renovate",i=JSON.stringify(n),a=t,!I(Buffer.from(a),Buffer.from(function(e,t){return"sha1="+G.createHmac("sha1",e).update(t).digest("hex")}(s,i))))return r("Failed to verify signature")}var s,i,a;const c=function(e,t){const{action:r}=t,{id:n}=t.installation||{},{full_name:o}=t.repository||{};if(["integration_installation","integration_installation_repositories"].includes(e))return re.trace({repository:o},"Discarding event type: "+e),null;if(re.debug({event:e,action:r,installationId:n,repository:o},"Received webhook event"),"installation"===e){if("created"===r){const e=t.installation.account.accountId||t.installation.account.id;St(t.repositories,e,t.installation.id);const r=t.repositories.map(e=>e.full_name);return{task:"enqueue",installationId:n,repositories:r,reason:"installed"}}return"deleted"===r?(global.repoVerboseList=global.repoVerboseList?global.repoVerboseList.filter(e=>e.installationId!==n):[],{task:"uninstall",installationId:n}):(re.warn({installationId:n},"Unknown installation action: "+r),null)}if("installation_repositories"===e){if("added"===r){const e=t.installation.account.accountId||t.installation.account.id;St(t.repositories_added,e,t.installation.id);const r=t.repositories_added.map(e=>e.full_name);return{task:"enqueue",installationId:n,repositories:r,reason:"repositories-added"}}if("removed"===r){global.repoVerboseList=global.repoVerboseList||[],t.repositories_removed.forEach(e=>{global.repoVerboseList=global.repoVerboseList.filter(t=>t.id!==e.id)});const e=t.repositories_removed.map(e=>e.full_name);return{task:"dequeue",installationId:n,repositories:e}}return re.warn({installationId:n},"Unknown installation_repositories action: "+r),null}if("pull_request"===e){if(t.pull_request.user.login!==global.botUsername)return re.debug({repository:o},"Ignoring non-Bot PR event"),null;if("closed"===r){if(t.pull_request.merged_at){const e=t.pull_request.merged_by&&t.pull_request.merged_by.login===global.botUsername;return{task:"enqueue",installationId:n,repository:o,reason:e?"automerge":"manual-pr-merge"}}return t.pull_request.title.endsWith("- autoclosed")?(re.debug({repository:o},"Ignoring PR autoclose event"),null):{task:"enqueue",installationId:n,repository:o,reason:"manual-pr-close"}}return"edited"===r&&t.changes&&t.changes.title&&t.pull_request.title.startsWith("rebase!")||"labeled"===r&&"rebase"===t.label.name||"edited"===r&&t.changes&&t.changes.body&&(t.pull_request.body.includes("- [x] \x3c!-- renovate-rebase --\x3e")||t.pull_request.body.includes("- [x] \x3c!-- rebase-check --\x3e")||t.pull_request.body.includes("- [x] \x3c!-- whitesource-remediate-rebase --\x3e"))?{task:"enqueue",installationId:n,repository:o,reason:"rebase-request"}:(re.debug({repository:o},"Ignoring pull_request action: "+r),null)}if("issues"===e){const e=t.issue.user.login;return e!==global.botUsername?(re.debug({repository:o,botUsername:global.botUsername,issueCreator:e},"Ignoring event for a GitHub issue created by someone else"),null):t.issue.body&&t.issue.body.includes("<REMEDIATE>")?{task:"enqueue",installationId:n,repository:o,reason:"remediate"}:"edited"===r&&t.changes&&t.changes.body&&t.issue.body.includes("- [x] \x3c!--")?{task:"enqueue",installationId:n,repository:o,reason:"master-issue-check"}:(re.debug({repository:o},"Ignoring issue action: "+r),null)}if("push"===e){const e=t.ref.replace("refs/heads/","");return t.pusher.name===global.botUsername?(re.debug({repository:o,branch:e},"Ignoring non-bot commit"),null):"0000000000000000000000000000000000000000"===t.after?(re.debug({repository:o,branch:e},"Ignoring onboarding branch deletion"),null):"renovate/configure"===e||"whitesource-remediate/configure"===e?{task:"enqueue",installationId:n,repository:o,reason:"onboarding-update"}:"master"===e||"main"===e||"develop"===e?t.commits.some(e=>{const t=e.added.concat(e.removed).concat(e.modified);return t.includes(".whitesource")||t.includes("renovate.json")||t.includes("package.json")||t.includes("go.mod")||t.includes("Dockerfile")||t.includes("WORKSPACE")||t.includes(".nvmrc")||t.some(e=>e.endsWith("/package.json"))||t.some(e=>e.endsWith("/package.js"))||t.some(e=>e.endsWith("/Dockerfile"))})?{task:"enqueue",installationId:n,repository:o,reason:"master-commit"}:(re.debug({repository:o},"Ignoring unimportant commits to master"),null):e.startsWith("renovate/")||e.startsWith("whitesoure-remediate/")?{task:"enqueue",installationId:n,repository:o,reason:"pr-update"}:(re.debug({repository:o},"Ignoring unimportant push event"),null)}return re.debug({repository:o},"Ignoring event type: "+e),null}(o,n);if(!c)return t.sendStatus(200);if(re.info({result:c},"Event result"),"enqueue"===c.task){const t=c.repositories||[c.repository],r=t.map(e=>({repository:e,uniqueKey:e})),n=t.map(()=>c.installationId);he(e.headers["ws-log-context"],c.reason,r,n)}else"dequeue"===c.task?be(c.repositories):"uninstall"===c.task?(u=c.installationId,re.debug({installationId:u},"Job queue: deleting jobs for installation"),de=de.filter(e=>e.installationId!==u)):re.error("Unknown event result");var u;return t.sendStatus(200)}let wt=new Set;let At=null;async function It(e,t){if(global.remediateServerUrl)return void re.debug("Skipping webhook listener as in worker mode");re.debug("Starting webhook listener");function r(e,t,r){const n=e.headers["ws-log-context"];n&&re.debug({logContext:n},"Webhook received"),At=new Date;try{if(e.headers["x-github-event"])kt(e,t);else if(e.headers["x-gitlab-event"])!function(e,t){function r(e){t.status(400).send({error:e})}if("null"!==process.env.WEBHOOK_SECRET){const t=e.headers["x-gitlab-token"]||"";if(!t)return r("No token found in the request");if(t!==(process.env.WEBHOOK_SECRET||"renovate"))return re.info("Discarding webhook with incorrect secret: "+t),r("Failed to verify token")}const n=e.headers["x-gitlab-event"];if(!n)return r("No event found in the request");const o=function(e,t){re.trace({eventDescription:e,payload:t},"processEvent");let{path_with_namespace:r}=t.project||{};r=r||t.project_path_with_namespace;const n=t.event_name||t.event_type;if(!r){const e=t;return e.key&&(e.key="**************"),re.info({modifiedPayload:e},"Ignoring event with no repository"),null}return wt.has(r)||"issue"===n||"confidential_issue"===n||"user_add_to_team"===t.event_name?function(e,t){const r=e.event_name||e.event_type;if(["project_create","project_destroy","project_rename","project_transfer","project_update","user_create","user_destroy","user_failed_login","user_rename","key_create","key_destroy","group_create","group_destroy","group_rename","user_add_to_group","user_remove_from_group","tag_push","repository_update"].includes(r))return re.trace("Discarding event type: "+r),null;if(re.info({event:r,repository:t},"Received webhook event"),"user_add_to_team"===r){if(e.user_id!==global.botUserId)return re.info("Ignoring non-bot team addition"),null;const r=e.access_level;return"Guest"===r||"Reporter"===r?(re.warn({repository:t,accessLevel:r},"Bot was added to project with insufficient permissions"),null):(wt.add(t),{task:"enqueue",repository:t,reason:"repositories-added"})}if("user_remove_from_team"===r)return e.user_id!==global.botUserId?(re.info("Ignoring non-bot user removal"),null):(wt.delete(t),{task:"dequeue",repository:t});if("issue"===r||"confidential_issue"===r){const r=e.object_attributes.author_id;if(r!==global.botUserId)return re.debug({repository:t,issueAuthor:r},"Ignoring issue because it is not our bot issue"),null;if(e.changes&&e.changes.description&&e.changes.description.current.includes("- [x] \x3c!--"))return re.info("Enqueuing job because master issue has been checked"),{task:"enqueue",repository:t,reason:"master-issue-check"};if(e.changes&&e.changes.description&&e.changes.description.current.includes("<REMEDIATE>"))return re.info("Enqueuing job because issue contains Remediate data"),{task:"enqueue",repository:t,reason:"remediate"};re.info("Ignoring bot issue that does not contain Remediate data")}if("merge_request"===r){const r=e.object_attributes.author_id;if(r!==global.botUserId)return re.info({repository:t,mrAuthor:r},"Ignoring non-bot MR event"),null;const{action:n,state:o}=e.object_attributes,s=e.user.username===global.botUsername;return"merge"===n?{task:"enqueue",repository:t,reason:s?"automerge":"manual-pr-merge"}:"close"===n?s?(re.info({repository:t},"Ignoring MR autoclose event"),null):{task:"enqueue",repository:t,reason:"manual-pr-close"}:"update"===n?"closed"===o&&e.changes&&e.changes.title&&e.changes.title.previous!==e.changes.title.current?{task:"enqueue",repository:t,reason:"closed-pr-rename"}:"opened"===o&&e.changes&&e.changes.title&&e.changes.title.current&&e.changes.title&&e.changes.title.current.startsWith("rebase!")||"opened"===o&&e.changes&&e.changes.labels&&e.changes.labels.current&&e.changes.labels.current.some(e=>"rebase"===e.title)||"opened"===o&&e.changes&&e.changes.description&&(e.changes.description.current.includes("- [x] \x3c!-- renovate-rebase --\x3e")||e.changes.description.current.includes("- [x] \x3c!-- rebase-check --\x3e")||e.changes.description.current.includes("- [x] \x3c!-- whitesource-remediate-rebase --\x3e"))?{task:"enqueue",repository:t,reason:"rebase-request"}:(re.info("Ignoring unimportant MR update"),null):(re.info("Ignoring unimportant MR action: "+n),null)}if("push"===r){const r=e.ref.replace("refs/heads/","");return e.user_id===global.botUserId?(re.info({repository:t,branch:r},"Ignoring bot commit"),null):"0000000000000000000000000000000000000000"===e.after?(re.info({repository:t,branch:r},"Ignoring onboarding branch deletion"),null):"renovate/configure"===r||"whitesource-remediate/configure"===r?{task:"enqueue",repository:t,reason:"onboarding-update"}:"master"===r||"main"===r||"develop"===r?e.commits.some(e=>{const t=e.added.concat(e.removed).concat(e.modified);return t.includes("renovate.json")||t.includes("package.json")||t.includes("go.mod")||t.includes("Dockerfile")||t.includes("WORKSPACE")||t.includes(".nvmrc")||t.includes(".whitesource")||t.some(e=>e.endsWith("/package.json"))||t.some(e=>e.endsWith("/package.js"))||t.some(e=>e.endsWith("/Dockerfile"))})?{task:"enqueue",repository:t,reason:"master-commit"}:(re.info({repository:t},"Ignoring unimportant commits to master"),null):r.startsWith("renovate/")||r.startsWith("whitesource-remediate/")?{task:"enqueue",repository:t,reason:"pr-update"}:(re.info({repository:t},"Ignoring unimportant push event"),null)}return re.info({repository:t},"Ignoring event type: "+r),null}(t,r):(re.info("Ignoring non-installed repo"),null)}(n,e.body);o?(re.info({result:o},"Event result"),"enqueue"===o.task?he(e.headers["ws-log-context"],o.reason,[{repository:o.repository,uniqueKey:o.repository}]):"dequeue"===o.task?be([o.repository]):re.error("Unknown event result"),t.sendStatus(200)):t.sendStatus(200)}(e,t);else if(e.headers["x-event-key"])"bitbucket"===process.env.WS_PLATFORM?function(e,t){function r(e){t.status(400).send({error:e})}if(!(e.headers.authorization||"").replace("JWT ","").length)return r("No token found in the request");const n=e.body.event;if(!n)return r("No event found in the request");const o=e.body,s=e.headers["ws-scm-installation-id"],i=e.headers["ws-scm-app-key"],a=function(e,t){let r;return re.trace({eventDescription:e,payload:t},"processEvent"),t.data.repository&&t.data.repository.project&&t.data.repository.project.key&&(r=t.data.repository.full_name),r?function(e,t){const r=e.event;if(Nt.includes(r))return re.trace("Discarding event type: "+r),null;if(re.info({event:r,repository:t},"Received webhook event"),r.startsWith("pullrequest:")){const r=e.data.pullrequest.source.branch.name;return r.startsWith("whitesource-remediate")||re.info({repository:t,branchName:r,botUserId:global.botUserId},"Ignoring non-bot PR event"),null}return re.info({repository:t},"Ignoring unknown event type: "+r),null}(t,r):(re.info({payload:t},"Ignoring event with no repository"),null)}(n,o);a?(re.info({result:a},"Event result"),"enqueue"===a.task?he(e.headers["ws-log-context"],a.reason,[{repository:a.repository,uniqueKey:a.repository}],[s],{appKey:i}):"dequeue"===a.task?be([a.repository]):re.error("Unknown event result"),t.sendStatus(200)):t.sendStatus(200)}(e,t):function(e,t){function r(e){t.status(400).send({error:e})}const n=(e.headers.authorization||"").replace("Bearer ","");if(!n.length)return r("No token found in the request");if(n!==process.env.RENOVATE_PASSWORD)return re.info("Discarding webhook with incorrect secret"),r("Failed to verify token");const o=e.body.eventKey;if(!o)return r("No event found in the request");const s=function(e,t){let r;return re.trace({eventDescription:e,payload:t},"processEvent"),t.repository&&t.repository.project&&t.repository.project.key&&(r=t.repository.project.key+"/"+t.repository.slug),r?function(e,t){const r=e.eventKey;if([].includes(r))return re.trace("Discarding event type: "+r),null;if(re.info({event:r,repository:t},"Received webhook event"),r.startsWith("issue:")){const r=e.actor.user;return r===global.botUsername?e.issue&&e.issue.body&&e.issue.body.includes("<REMEDIATE>")?{task:"enqueue",repository:t,reason:"remediate"}:(re.info("Ignoring unimportant bot issue event"),null):(re.info({repository:t,issueAuthor:r,botUserId:global.botUserId},"Ignoring non-bot issue event"),null)}if(r.startsWith("pullrequest:")){const r=e.pullRequest.author.user;return r===global.botUsername?{task:"enqueue",repository:t,reason:"pr-update"}:(re.info({repository:t,prAuthor:r,botUserId:global.botUserId},"Ignoring non-bot PR event"),null)}return re.info({repository:t},"Ignoring unknown event type: "+r),null}(t,r):(re.info({payload:t},"Ignoring event with no repository"),null)}(o,e.body);s?(re.info({result:s},"Event result"),"enqueue"===s.task?he(e.headers["ws-log-context"],s.reason,[{repository:s.repository,uniqueKey:s.repository}]):"dequeue"===s.task?be([s.repository]):re.error("Unknown event result"),t.sendStatus(200)):t.sendStatus(200)}(e,t);else if(e.headers["x-vss-subscriptionid"])!function(e,t){const r=e.body;function n(e){return t.status(400).send({error:e})}const o=r.eventType;if(!o)return n("No event found in the request");const s=function(e){const[,t]=e.split(" "),r=Buffer.from(t,"base64"),[,n]=r.toString("ascii").split(":");return n}(e.headers.authorization);if(!s)return n("No secret found in the request");const i=e.body.resource.repository.project.id;if(!s)return n("No project id found in the request");if(s!==G.createHash("sha1").update(i).digest("hex").toString())return re.info("Discarding webhook with incorrect secret: "+s),n("Failed to verify secret");const a=function(e,t,r){re.trace({payload:t},"processEvent");const n=t.eventType;if(!["git.push","git.pullrequest.updated","git.pullrequest.created"].includes(n))return re.trace({payload:t},"Discarding event type: "+n),null;const o=t.resourceContainers.collection.baseUrl.replace("https://dev.azure.com/","").replace("/",""),s=t.resource.repository.project.name,i=t.resource.repository.id,a=t.resource.repository.name,c=t.resourceContainers.collection.id,u=t.resource.repository.project.id,l=`${s}/${a}`,p=`${o}/${s}/${a}`;if("git.pullrequest.created"===e||"git.pullrequest.updated"===e)return!r===t.resource.createdBy.id?(re.debug({repository:l},"Ignoring non-Bot PR event"),null):"completed"===t.resource.status&&"succeeded"===t.resource.mergeStatus?{task:"enqueue",repository:l,uniqueKey:p,reason:t.resource.closedBy.id===r?"automerge":"manual-pr-merge",collection:o,collectionId:c,accountId:u,repoId:i}:"abandoned"===t.resource.status?t.resource.title.endsWith("- autoclosed")?(re.debug({repository:l},"Ignoring PR autoclose event"),null):{task:"enqueue",repository:l,uniqueKey:p,reason:"manual-pr-close",collection:o,collectionId:c,accountId:u,repoId:i}:"active"===t.resource.status&&t.resource.description&&(t.resource.description.includes("- [X] \x3c!-- renovate-rebase --\x3e")||t.resource.description.includes("- [X] \x3c!-- rebase-check --\x3e")||t.resource.description.includes("- [X] \x3c!-- whitesource-remediate-rebase --\x3e"))?{task:"enqueue",repository:l,uniqueKey:p,reason:"rebase-request",collection:o,collectionId:c,accountId:u,repoId:i}:(re.debug({repository:l},"Ignoring pull request event: "+e),null);if("git.push"===e&&t.resource.refUpdates[0].name){const e=t.resource.refUpdates[0].name.replace("refs/heads/","");if("renovate/configure"===e||"whitesource-remediate/configure"===e)return{task:"enqueue",repository:l,uniqueKey:p,reason:"onboarding-update",collection:o,collectionId:c,accountId:u,repoId:i};if(e.startsWith("renovate/")||e.startsWith("whitesoure-remediate/"))return{task:"enqueue",repository:l,uniqueKey:p,reason:"pr-update",collection:o,collectionId:c,accountId:u,repoId:i}}return null}(o,r,e.headers["ws-scm-user-id"]);re.info({result:a},"Azure - Process Event Result"),a&&("enqueue"===a.task?he(e.headers["ws-log-context"],a.reason,[{repository:a.repository,uniqueKey:a.uniqueKey}],[a.collectionId],{vaultKey:e.headers["ws-secret-name"],collection:a.collection,collectionId:a.collectionId,accountId:a.accountId,repoId:a.repoId}):"dequeue"===a.task?be([a.uniqueKey]):re.error("Unknown event result")),t.sendStatus(200)}(e,t);else{if(!e.headers["ws-component"])return re.info({logContext:n,headers:e.headers,body:e.body},"Unknown webhook"),r();!function(e,t){function r(e){t.status(400).send({error:e})}const n=e.body;if(re.trace({payload:n},"Event payload"),"null"!==process.env.WEBHOOK_SECRET){const t=e.headers.webhook_secret||"";if(!t)return r("No signature found in the request");if(process.env.WEBHOOK_SECRET!==t)return r("Failed to verify signature")}const o=function(e){if(!Y)return;const t=(e||"").replace("Bearer ","");return t.length?t!==Y?"Secret provided is incorrect":void 0:"Secret is required but is missing"}(e.headers.authorization);if(o)return r(o);const s=function(e,t){const{repository:r,installationId:n}=e;if(r){re.debug({installationId:n,repository:r},"Received webhook event");const o=e.isScheduled?"scheduled":"remediate";if("azure"===process.env.WS_PLATFORM){const s=e.collectionId,i=e.accountId,a=e.repositoryId;return{task:"enqueue",repository:r,uniqueKey:`${e.installationId}/${r}`,reason:o,collection:n,installationId:s,accountId:i,repoId:a,vaultKey:t["ws-secret-name"]}}const s={task:"enqueue",repository:r,uniqueKey:r,reason:o,installationId:n,repoId:e.repositoryId};return"bitbucket"===process.env.WS_PLATFORM&&(s.vaultKey="BB-"+G.createHash("SHA1").update(n).digest("hex"),s.installationId=t["ws-scm-installation-id"],s.appKey=t["ws-scm-app-key"]),s}return null}(n,e.headers);s?(re.info({result:s},"Event result"),"enqueue"===s.task?he(e.headers["ws-log-context"],s.reason,[{repository:s.repository,uniqueKey:s.uniqueKey}],[s.installationId],{vaultKey:s.vaultKey,collection:s.collection,collectionId:s.installationId,accountId:s.accountId,repoId:s.repoId,appKey:s.appKey}):re.error("Unknown event result"),t.sendStatus(200)):t.sendStatus(200)}(e,t)}return Promise.resolve()}catch(e){return re.error({logContext:n,err:e,message:e.message,stack:e.stack},"Error thrown processing webhook"),t.sendStatus(500)}}process.env.DATABASE_URL&&process.env.DATABASE_URL,"github"===process.env.RENOVATE_PLATFORM?re.debug("Initialized GitHub webhook handler"):"gitlab"===process.env.RENOVATE_PLATFORM?await async function(e){let t;try{let r=Ne.resolve(process.env.RENOVATE_ENDPOINT,"projects?membership=true&per_page=100&min_access_level=30"),o=[];do{const e={headers:{"PRIVATE-TOKEN":process.env.RENOVATE_TOKEN},responseType:"json"},t=await n(r,e);o=o.concat(t.body);const s=V(t.headers.link);r=s&&s.next?s.next.url:null}while(r);re.info(`Discovered reposistory count: ${o.length}`),t=o.map(e=>({id:e.id,repository:e.path_with_namespace,isPrivate:"private"===e.visibility})),re.trace({config:t},"All repos"),t.length&&e.autodiscoverFilter&&(re.info("Applying autodiscoverFilter"),t=t.filter(t=>P(t.repository,e.autodiscoverFilter)),re.trace({config:t},"Finished applying autodiscoverFilter"),t.length||re.info("None of the discovered projects matched the filter")),re.info({allRepos:t},"Repository list for integration"),wt=new Set(t.map(e=>e.repository))}catch(e){if(e.statusCode&&e.statusCode>=500&&e.statusCode<600)return void re.warn({err:e},"Error reaching GitLab. Scheduler could not run.");re.error({err:e,message:e.message},"Unknown gitlabScheduler error")}re.info("Initialized GitLab webhook handler")}(t):"azure"===process.env.RENOVATE_PLATFORM?re.debug("Initialized Azure webhook handler"):re.info("Initialized Bitbucket webhook handler"),e.post("/webhook",(e,t,n)=>r(e,t,n)),e.post("/renovate-webhook",(e,t,n)=>r(e,t,n))}const Pt=u(import.meta.url)("os"),Vt={requested:!1,cmd:"",cron:"",dirs:[],mode:"off"},Dt={encoding:"utf-8",stdio:"inherit",env:{},maxBuffer:1/0},Lt={config:{...Vt},init(t,r="/tmp/renovate/cache, /tmp/renovate/repos, /home/ubuntu",n=Pt.tmpdir()){if(re.debug({userInputMode:t,dirs:r},"Cleanup configuration input"),this.processUserInput(t),this.config.dirs=(o=r,e.undefined(o)?[]:o.split(",").map(e=>e.trim()).filter(e.nonEmptyString)),"off"!==this.config.mode){try{const t=function(e){re.debug("Creating cleanup reference file");const t=`.ref.${Math.floor(Date.now()/1e3)}`,r=g.posix.join(e,t);p.writeFileSync(r,"");const n=p.statSync(r).uid;return re.debug({path:r,owner:n},"Successfully created cleanup reference file"),{path:r,owner:n}}(n);this.config.cmd=function(t,r,n){const o=t.map(e=>function(e,t,r){return[`find ${e} -type f -user ${r.toString()} -newercc ${t} -delete`,`find ${e} -type l -user ${r.toString()} -newercc ${t} -delete`,`find ${e} -type d -user ${r.toString()} -empty -newercc ${t} -delete`].join("; ")}(e,r,n));return e.emptyArray(o)?"":[...o,"true"].join("; ")}(this.config.dirs,t.path,t.owner)}catch(e){re.error({err:e},"Error creating reference file")}if(!e.nonEmptyString(this.config.cmd))return re.warn("Generated cleanup command is empty; disabling cleanup"),this.config.mode="off",void(this.config.requested=!1);"cron"===this.config.mode&&(this.config.cron=t,function(e){re.info({cronTime:e,localTime:(new Date).toString()},"Starting worker cleanup scheduler");const t=new S({cronTime:e,onTick:()=>{Lt.request(),re.debug("Cron; cleanup requested")},runOnInit:!1,start:!1});t.start(),re.info("Worker cleanup scheduler started"),process.on("SIGTERM",()=>xt(t)),process.on("exit",()=>xt(t))}(t)),re.info({cleanupConfig:this.config},"Resolved file system cleanup config")}else re.info("Worker file system cleanup handler is disabled");var o},processUserInput(e="off"){switch(e){case"always":this.config.requested=!0,this.config.mode="always";break;case"off":this.config.requested=!1,this.config.mode="off";break;default:this.config.requested=!1,this.config.mode="cron"}},reset(){this.config={...Vt}},request(){re.debug("File system cleanup requested"),this.config.requested=!0},async run(){if("off"!==this.config.mode)if(this.config.requested){re.debug({config:this.config},"Performing file system cleanup");try{await w(this.config.cmd,Dt),"cron"===this.config.mode&&(this.config.requested=!1),re.debug("File system cleanup completed successfully")}catch(e){re.error({err:e},"Error occurred during file system cleanup")}}else re.trace("File system cleanup was not requested; skipping cleanup");else re.trace("File system cleanup is disabled; skipping cleanup")}};function xt(e){re.debug("Stopping scheduler"),e.stop()}function Ut(e){const t=[];"https://api.github.com/"!==process.env.RENOVATE_ENDPOINT&&process.env.GITHUB_COM_TOKEN&&(re.debug("Setting host rule for github.com"),t.push({hostType:"github",matchHost:"github.com",token:process.env.GITHUB_COM_TOKEN})),e.hostRules&&e.hostRules.forEach(e=>{re.debug({config:e},"Adding host rule"),t.push(e)}),t.length&&(e.hostRules=t)}function Mt(e,t){if(!t)return;let r=e.hostRules;r||(r=[]),t.forEach(e=>{re.debug({config:e},"Adding host rule"),r.push(e)}),r.length&&(e.hostRules=r)}function Ct(e,t){let r;if(process.env.MC_API_SECRET_STATIC)r=process.env.MC_API_SECRET_STATIC,re.debug("static token found");else{if(!t)return void re.debug("merge-confidence missing token");r=t,re.debug("mcJwt token found")}Mt(e,[{hostType:"merge-confidence",token:r}])}const jt=process.env.MEND_RNV_DOCKER_HUB_ACCOUNTS;let qt,Ft,Kt=0;function Bt(e){if(qt=$t(jt,"docker.io",qt),Ft=$t(jt,"hub.docker.com",Ft),Kt>1e4&&(Kt=0),qt.length>0){const t=Kt%qt.length;Mt(e,[qt[t]])}if(Ft.length>0){const t=Kt%Ft.length;Mt(e,[Ft[t]])}Kt+=1}function $t(t,r,n){const o=[];if(void 0!==n)return n;if(!t)return o;try{const n=JSON.parse(t);for(const t of n)e.string(t.user)&&e.string(t.token)?(re.debug(`creating host rule for: ${r}`),o.push({hostType:"docker",matchHost:r,username:t.user,password:t.token})):re.warn("Invalid docker account definition - missing user or token")}catch(e){re.error("initDockerHubRules error",e)}return o}function Wt(e){return Gt.has(e.msg)}const Gt=new Set(["Caught initRepo error","Dependency lookup unauthorized. Please add authentication with a hostRule","dns lookup error","Existing branch contains all necessary lock file updates","Error while setting cache value","Failed to add assignees","git clone completed","GraphQL page size: shrinking","http statistics","HTTP statistics","isLockFileUpdate without updateLockedDependency","Manifest schema version is not 2","Renovate repository PR statistics","Repository timing splits (milliseconds)","Unexpected depNameConstraint","Using containerbase dynamic installs","Using docker to execute"]),Ht=u(import.meta.url)("node:stream"),Yt=u(import.meta.url)("stream"),Jt=u(import.meta.url)("zlib"),zt={client:void 0,initialize(){this.client=new M},async verify(e,t){const r=new U({Body:(new Date).toISOString(),Bucket:e,Key:g.posix.join(t,".mend-remediate-s3-write-test")});try{await this.client.send(r),re.debug({bucket:e,keyPath:t},"Successfully verified write permissions to the S3 bucket at the specified subdirectory.")}catch(r){const n=g.posix.join(e,t);throw new Error(`Failed to verify write permissions to "${n}": ${r.message}`)}},async upload(e,t,r,n={}){const o=new C({client:this.client,params:{Body:r,Bucket:e,Key:t,...n},queueSize:4,partSize:5242880,leavePartsOnError:!1});o.on("httpUploadProgress",e=>{re.trace({progress:e},"Upload progress")}),await o.done()}},Xt="MEND_REMEDIATE_LOG_HISTORY_S3",Qt={saveDir:"",bucket:"",keyPath:"",async mustInitialize(t=`${g.posix.join(Pt.tmpdir(),"renovate","logs")}`,r=process.env[Xt]){if(!e.nonEmptyString(r))return void re.info(`Saving Renovate CLI logs to AWS S3 is disabled.\nTo enable it, set the "${Xt}" environment variable.\nFor example, ${Xt}='s3://<BUCKET>/<OPTIONAL_PATH>'.`);const n=j(r);if(e.nullOrUndefined(n))throw new Error(`could not parse the provided S3 bucket URL: "${r}"`);await zt.initialize(),await zt.verify(n.Bucket,n.Key),p.ensureDirSync(t),this.saveDir=t,this.bucket=n.Bucket,this.keyPath=n.Key,re.info("Saving Renovate CLI logs to AWS S3 is enabled")},key(e){return g.posix.join(this.keyPath,e)},logFilePath(t,r){if(e.nonEmptyString(t)&&e.nonEmptyString(r))return g.posix.join(this.saveDir,...t.split("/"),`${r}.log`).toLowerCase()},enabled(){return!!this.bucket},async upload(t,r){if(e.nonEmptyString(t))if(e.nonEmptyString(r))if(p.existsSync(r))try{const e=g.posix.join(...t.split("/"),`${g.basename(r)}.gz`),n=this.key(e),o=p.createReadStream(r),s=new Yt.PassThrough;o.pipe((0,Jt.createGzip)()).pipe(s),await zt.upload(this.bucket,n,s,{ContentType:"text/plain",ContentEncoding:"gzip"}),re.debug({bucket:this.bucket,key:n},"Log file uploaded successfully")}catch(e){re.error({err:e},"Failed to upload log file")}else re.warn({logPath:r},"Log file does not exist; aborting log upload...");else re.warn("Invalid log file path; aborting log upload...");else re.warn("Repository not provided; aborting log upload...")}};function Zt(e,t){return Qt.enabled()?Qt.logFilePath(e,t):""}const er=D({deterministic:!0});async function tr(t,r,n,o,s,i){const a=Ve(r),c=Ve(n),u=i??Se.mkdtempSync(g.posix.join(Pt.tmpdir(),"renovate-")),l=g.posix.join(u,"static-config.json");Se.writeFileSync(l,er(c));const f={RENOVATE_AUTODISCOVER:"false",RENOVATE_CONFIG:(m=er(a),m.replace(/\\\\n/g,"\\n")),RENOVATE_X_STATIC_REPO_CONFIG_FILE:l};var m;a.endpoint&&(f.RENOVATE_ENDPOINT=a.endpoint),a.token&&(f.RENOVATE_TOKEN=a.token),s&&(f.RENOVATE_LOG_CONTEXT=s);const h=Zt(t,s);e.nonEmptyString(h)&&(f.RENOVATE_LOG_FILE=h,f.RENOVATE_LOG_FILE_LEVEL="debug");try{await async function(t,r,n,o){let s,i,a;try{const{cmd:a,cwd:u}=function(t,r,n="development"===process.env.RNV_NODE_ENV){const o=r?.trim(),s=t?.trim();if(n)return re.debug("Running Renovate in local development mode using `npm exec`"),{cmd:rr([`NODE_OPTIONS="${o??""}"`,"npm exec -- renovate"])};if(!e.nonEmptyString(s))throw new Error("renovateExecCMD: Missing required argument: nodePath");return{cwd:"/usr/src/app/",cmd:rr([s,nr(r),"/usr/src/mend/node_modules/renovate/dist/renovate.js"])}}(t,r),l=function(e,t=De){const r={...e};for(const e of t)delete r[e];return r}({...process.env,...n});let p,g="inherit";(function(t,r=!1){return e.undefined(t)?r:"true"===t.trim().toLowerCase()})(process.env.MEND_REMEDIATE_REDUCED_LOGS)&&(l.LOG_FORMAT="json",g="pipe",i=function(e){const t=new Ht.PassThrough,r=x(),n=e=>{t.write(e)};return t.pipe(r).on("data",e),n.dispose=()=>{t.end(),t.destroy(),r.end(),r.destroy()},n}((c=Wt,function(t){const r=function(t){const r=function(t){try{const r=JSON.parse(t);if(!e.nonEmptyObject(r))return;const{level:n,msg:o,...s}=r;return{level:n,meta:s,msg:o}}catch(e){d.error({err:e},"Error parsing log line")}}(t);if(!e.nonEmptyObject(r))return;const{level:n,meta:o,msg:s}=r;if(!e.number(n))return void d.warn({level:n},"Processing log event failed; level is not a number");const i=L.nameFromLevel[n];if(e.nonEmptyString(i))return{level:n,meta:o,msg:e.string(s)?s:void 0};d.warn({level:n},"Unsupported log level")}(t);e.nullOrUndefined(r)||(r.level>=L.INFO||c(r))&&function(t){const r=L.nameFromLevel[t.level];e.string(t.msg)?d[r](t.meta,t.msg):d[r](t.meta)}(r)})),p={stdout:[i]}),re.debug({cmd:a},"Executing Renovate run command"),await w(a,{encoding:"utf-8",maxBuffer:1/0,timeout:o,cwd:u,env:l,stdio:g,outputListeners:p}),s="success"}catch(e){a=e,"SIGTERM"===e.signal?(s="timeout",re.error({err:e},"renovate cli timeout reached")):[1,2].includes(e.exitCode)?(s="cli-error",re.error({err:e},"renovate cli error")):(s="unknown-error",re.fatal({err:e},"renovate cli unknown error"))}finally{i?.dispose()}var c;return{status:s,err:a}}(process.env.DOCKERFILE_NODE_DEFAULT_PATH,process.env.RENOVATE_NODE_ARGS,f,o)}finally{try{p.removeSync(u)}catch(e){re.warn({err:e},"error removing renovate temp job dir")}}await Lt.run()}function rr(e){return e.filter(Boolean).join(" ")}function nr(t){if(!e.undefined(t))return t.split(" ").filter(Boolean).map(e=>`"${e}"`).join(" ")}let or,sr=null,ir=!1;process.on("SIGTERM",()=>{re.info("Received SIGTERM"),ir=!0,global.jobTimeoutCheck&&clearTimeout(global.jobTimeoutCheck)});let ar,cr,ur,lr=null,pr=null,dr=null,gr=null,fr=null;async function mr(){gr&&(new Date).getTime()-gr.getTime()>ar&&(re.fatal({currentJob:dr,currentJobStart:gr,jobTimeoutMs:ar},"Job timeout - exiting to allow container restart"),await Ee(dr),process.exit(1)),global.jobTimeoutCheck=setTimeout(mr,ar)}async function hr(e,t){let r=null;try{const t=new f,n=new m(process.env.AZURE_KEYVAULT_LOCATION,t);r=(await n.getSecret(e)).value,re.info("Successfully obtained api key from Azure keyvault"),re.trace({keyVaultToken:r},"apiToken")}catch(e){re.error(e.message),re.error("Unable to access azure keyvault API for "+t)}return r}async function br(t){if(dr){try{await Ee(dr),e.nonEmptyString(t)&&await async function(t,r){Qt.enabled()&&e.nonEmptyString(r)&&await Qt.upload(t,r)}(dr.repository,t)}catch(e){re.error({err:e},"Error finalizing current job")}lr=dr,pr=gr,dr=null,gr=null}}function yr(e){let t=null;return"azure"===process.env.WS_PLATFORM&&(t=async function(e){return sr=await hr(e.params.vaultKey,e.repository),{RENOVATE_ENDPOINT:process.env.RENOVATE_ENDPOINT+e.params.collection,RENOVATE_PLATFORM:"azure",RENOVATE_TOKEN:sr}}(e)),"bitbucket"===process.env.WS_PLATFORM&&(t=async function(e){const t=await hr(e.params.vaultKey,e.repository),r=process.env.RENOVATE_ENDPOINT,o=function(e,t,r){if(!e)return null;const n=Date.now()/1e3,o={iat:n,exp:n+540,sub:e,iss:t};return b.sign(o,r)}(e.installationId,e.params.appKey,t),s={body:"grant_type=urn:bitbucket:oauth2:jwt",headers:{"Content-Type":"application/x-www-form-urlencoded",Authorization:"JWT "+o},timeout:{request:1e4}};let i;try{i=await n.post("https://bitbucket.org/site/oauth2/access_token",s).json()}catch(e){re.debug({err:e},"Error retrieving access token from Bitbucket")}return sr=i.access_token,{RENOVATE_ENDPOINT:r,RENOVATE_PLATFORM:"bitbucket",RENOVATE_TOKEN:sr}}(e)),"github"===process.env.RENOVATE_PLATFORM&&(t=async function(e){let t;try{t=await async function(e){const t=`${yt}app/installations/${e}/access_tokens`,r={headers:{accept:"application/vnd.github.machine-man-preview+json",authorization:`Bearer ${_t()}`}};return(await n.post(t,r).json()).token}(e.installationId),process.env.RENOVATE_TOKEN=t}catch(t){throw re.error({err:t,installationId:e.installationId},"Error getting installation token"),new Error("installation-token-error")}return sr=t,{RENOVATE_ENDPOINT:yt,RENOVATE_PLATFORM:"github",RENOVATE_TOKEN:t,RENOVATE_USERNAME:global.botUsername,RENOVATE_GIT_AUTHOR:global.gitAuthor}}(e)),t}async function vr(e,t){re.error({err:t},e),re.info("waiting 120 seconds before terminating..."),await l(12e4),process.exit(1)}function Er(t){if(e.nonEmptyString(t))try{p.removeSync(t),re.debug({logFile:t},"Successfully deleted log file")}catch(e){re.error({err:e,logFile:t},"Failed to remove log file")}}process.on("unhandledRejection",e=>{re.error({err:e},"Caught an unhandledRejection - exiting to attempt recovery. Container must be restarted"),process.exit(1)});const Rr=new Date;(async()=>{let u;var p;"enterprise"===process.env.WS_PLATFORM?global.appName="Mend Remediate":"github.com"===process.env.WS_PLATFORM?global.appName="Mend Remediate for GitHub.com":"azure"===process.env.WS_PLATFORM?global.appName="Mend Remediate for Azure Devops":"bitbucket"===process.env.WS_PLATFORM?global.appName="Mend Remediate for Bitbucket Cloud":(delete process.env.WS_PLATFORM,global.appName="Mend Renovate On-Prem"),re.info("Launching "+global.appName),process.env.WS_PLATFORM&&(u=await dt(),(p=u)&&(p.endpoint&&(process.env.RENOVATE_ENDPOINT=p.endpoint),p.password&&(process.env.RENOVATE_PASSWORD=p.password),p.platform&&(process.env.RENOVATE_PLATFORM=p.platform),p.privateKey&&(process.env.RENOVATE_PRIVATE_KEY=p.privateKey),p.token&&(process.env.RENOVATE_TOKEN=p.token),p.username&&(process.env.RENOVATE_USERNAME=p.username)),re.setMeta({name:"remediate"}),global.remediateServerUrl&&re.setMeta({name:"remediate-worker"}));let d=await c.parseConfigs(process.env,process.argv);await async function(e){re.info("Initializing Renovate core"),s(),global.appMode=!0,await i.init({...e,cacheDir:"/tmp/renovate/cache/renovate/"}),await async function(e){if(!process.env.CHECK_REDIS_ON_STARTUP)return;const t=e.redisUrl;if(!t)return;re.info({redisUrl:t},"Redis connectivity test starting");const r="test-connection",n=o(),s=o();try{re.debug({namespace:r,key:n,value:s},"set new value"),await i.set(r,n,s,5),re.debug({namespace:r,key:n},"reading value");const e=await a.get(r,n);s!==e&&(re.fatal({result:e},"Redis connectivity test failed - invalid result"),process.exit(1)),re.info("Redis connectivity test passed")}catch(e){re.fatal({err:e},"Redis connectivity test failed"),process.exit(1)}}(e)}(d),await Ot();const g=process.env.GITHUB_COM_TOKEN?("https://api.github.com/"===process.env.RENOVATE_ENDPOINT&&(re.warn("No need to configure GITHUB_COM_TOKEN for github.com - it will be ignored"),delete process.env.GITHUB_COM_TOKEN),{}):"https://api.github.com/"===process.env.RENOVATE_ENDPOINT||"github.com"===process.env.WS_PLATFORM?{}:(re.warn("You should configure GITHUB_COM_TOKEN as otherwise the github.com API is heavily rate limited. Release notes and github-sourced packages will now be disabled."),{fetchReleaseNotes:!1,packageRules:[{description:"Disable managers to avoid github.com requests and rate limiting",matchDatasources:["github-tags","github-releases"],enabled:!1}]});d=await c.parseConfigs(process.env,process.argv),e.nonEmptyArray(d.gitIgnoredAuthors)||(g.gitIgnoredAuthors=["bot@renovateapp.com","renovate@whitesourcesoftware.com"]),e.nonEmptyArray(d.hostRules)&&(g.hostRules=d.hostRules),function(){if(global.remediateServerUrl)re.debug("Skipping scheduler as in worker mode");else{re.debug("Starting scheduler");try{if(ht=process.env.RENOVATE_PLATFORM,"github"===process.env.RENOVATE_PLATFORM&&"github.com"===process.env.WS_PLATFORM)return ht=process.env.WS_PLATFORM,void re.info("Skipping job scheduler. Scheduled jobs will be initiated by the ws-controller.");if("azure"===process.env.RENOVATE_PLATFORM)return void re.info("Skipping job scheduler. Scheduled jobs will be initiated by the ws-controller.");bt=process.env.SCHEDULER_CRON||"0 * * * *",re.info("Using cron schedule: "+bt),re.debug("Current datetime = "+(new Date).toString()),mt=new S({cronTime:bt,onTick:()=>(Rt=new Date,async function(){re.info("Scheduler being triggered in controller");try{const e=`${process.env.WS_CONTROLLER_DESTINATION_URL||process.env.CONTROLLER_DESTINATION_URL}/remediate/scheduledJob?timestamp=${Date.now()}&jobType=${ht}-remediate-schedule`;await n(e,{timeout:{request:1e4}})}catch(e){re.error({err:e,message:e.message},"Problem communicating to the controller by the remediate scheduler")}}()),start:!1,runOnInit:!1})}catch(e){re.error("Invalid cron value"),process.exit(0)}mt.start(),re.info("Job scheduler started")}}(),async function(t){if(global.remediateServerOnly)re.debug("Skipping worker as in server mode only");else{or=t,re.debug("Starting worker");try{Lt.init(process.env.MEND_REMEDIATE_WORKER_CLEANUP,process.env.MEND_REMEDIATE_WORKER_CLEANUP_DIRS),await Qt.mustInitialize()}catch(e){await vr("Worker initialization failed",e)}!function(){if(!process.env.REMEDIATE_JOB_TIMEOUT_MINUTES)return;let e;try{e=parseInt(process.env.REMEDIATE_JOB_TIMEOUT_MINUTES,10)}catch(e){return void re.error("Cannot parse REMEDIATE_JOB_TIMEOUT_MINUTES")}e<30&&re.warn({jobTimeoutMinutes:e},"It is recommended to set REMEDIATE_JOB_TIMEOUT_MINUTES to at least 30"),ar=60*e*1e3,cr=ar-6e4,mr()}();try{process.env.RENOVATE_USER_AGENT=process.env.RENOVATE_USER_AGENT||process.env.WS_PLATFORM?"Mend Remediate":"Mend Renovate",re.debug("User agent = "+process.env.RENOVATE_USER_AGENT),global.remediateServerUrl&&re.info(`Using ${global.remediateServerUrl} as remediate-server url`),await async function(){for(;!ir;)try{const t=await ye();if(!t){re.debug("No job - sleeping 5s"),await l(5e3);continue}const{repository:r,logContext:n}=t,o=Zt(r,n);e.nonEmptyString(o)&&re.addStream(ee(o)),re.addMeta({repository:r}),n&&(fr=re.getContext(),re.setContext(n)),dr=t,gr=new Date;let s=null;try{s=await yr(t)}catch(e){re.debug({repository:r,err:e},"Error preparing repository data - finishing");continue}const{installationId:i,priority:a,reason:c}=t;re.info({priority:a,reason:c},"Processing repository");const u=await gt(r,s,or);Ut(u);const p=await ft(t,i),d=p.config;if(!d){re.info({repository:r},"Repository is not onboarded - skipping");continue}if(!1===d.enabled){re.info({repository:r},"Repository has no work to do - finishing");continue}try{Ct(u,p.mcJwt),Bt(u)}catch(e){re.debug({err:e},"Error setting hostRules - finishing");continue}try{re.debug({repository:r},"start renovating repository"),await tr(r,u,d,cr,n),re.debug({repository:r},"done renovating repository")}catch(e){re.error({err:e,message:e.message,repository:r},"Error renovating repository")}}finally{const e=Zt(dr?.repository,dr?.logContext);await br(e),re.removeStream(),re.removeMeta(["repository"]),fr&&re.setContext(fr),Er(e)}ir&&(re.info("Received SIGTERM - shutting down"),process.exit(0))}()}catch(e){await vr("renovateRepository error",e)}}}(g),ur=r(),ur.use(t.json({limit:"50mb",extended:!0})),ur.get("/",(e,t)=>{t.status(200).send({status:"OK"})}),ur.get("/status",Q,Z,(e,t)=>{const r={bootDate:Rr,scheduler:{platform:ht,cron:bt,lastScheduling:Rt},webhooks:{lastWebhookReceived:At},jobs:{lastEnqueueDate:se,lastJobDispatchDate:ie,lastJob:ae,lastJobFinished:ue,queueLength:de.length,totalJobsProcessed:ce},jobsInProgress:le,worker:{remediateServerEnabled:!!global.remediateServerUrl,remediateServerUrl:global.remediateServerUrl,previousJob:lr,previousJobStart:pr,currentJob:dr,currentJobStart:gr}};return t.status(200).send({status:r})}),process.env.WS_PLATFORM&&ur.get("/controller-connected",Q,async(e,t)=>{let r=!1;const o=`${process.env.WS_CONTROLLER_DESTINATION_URL||process.env.CONTROLLER_DESTINATION_URL}/payload/healthcheck`;try{200===(await n.get(o,{retry:0})).statusCode&&(r=!0)}catch(e){re.info("Unable to connect to the controller.")}t.status(200).send({connected:r})}),global.remediateServerOnly&&(re.debug("Enabling job API in server mode"),ur.get("/jobs/next",Q,async(e,t)=>{const r=await ye();t.status(200).send({job:r})}),ur.put("/jobs/finish",Q,async(e,t)=>{const r=e.body.job;await Ee(r),t.status(200).send({})})),await It(ur,d),function(){ur.use((e,t)=>{t.status(404).send({url:e.originalUrl,message:"Not found"})});const e=process.env.PORT||8080,t=ur.listen(e,()=>{re.info("Server bound to port "+t.address().port)})}()})();